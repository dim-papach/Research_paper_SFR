---
title: "Comparison of Catalogs"
format: html
toc: true
toc-depth: 2
theme: minti
bibliography: ../My_Library.bib
execute: 
  echo: true
  eval: true
---

# The data

In this script we will compare out 2 catalogs @kovlakasHeraklionExtragalacticCatalogue2021 and [@karachentsevUPDATEDNEARBYGALAXY2013, @karachentsevSTARFORMATIONPROPERTIES2013a]

-   The data have been joined based on their position in the sky (Ra, Dec, Distance).
-   We use TOPCAT to create two joins, an inner and an outer join
-   We will use the inner join for 1-1 comparisons
-   If we see that the data are similar we can use the outer join

```{python}
#| echo: false
import numpy as np
import matplotlib.pyplot as plt
from sklearn.metrics import r2_score
from astropy.io import ascii
from astropy.coordinates import SkyCoord
from astropy.table import Table, join, QTable
import astropy.units as u
from astropy.visualization import quantity_support
#quantity_support()
from astropy.modeling import models, fitting
from scipy.stats import pearsonr
import glob
import os
plt.style.use('ggplot')

dt = QTable(ascii.read("../tables/inner_join.ecsv"), masked=True)
```

The dataset we are going to use consists of `{python} len(dt)` galaxies and `{python} len(dt.colnames)`

# How are we going to compare the data?

## Scatter plots and $R^2$ calculation

1.  [$R^2$]{.underline}: Measures the proportion of variance explained by the linear model.
2.  [Slope of the Fitted Line]{.underline}: Should be close to 1 for a 1-1 correlation.[^1]
3.  [Pearson Correlation $\rho$]{.underline}: Measures the strength and direction of the linear relationship between two variables, ranging from -1 to 1. [^2]

[^1]: Fitting can be done using the uncertainties as weights. To get the standard weighting of 1/unc^2, assuming Gaussian errors, the weights to pass to the fitting are 1/unc.
[^2]: In simple linear regression, $R^2$ is the square of the Pearson correlation coefficient $\rho$.

```{python}
def compare_data(x, y, unc = None):
    """
    Performs a linear comparison between two datasets.
    
    This function fits a linear model to the data, calculates the slope and intercept of the fitted line,
    and computes the R-squared value and Pearson correlation coefficient to assess the fit quality.
    
    Parameters:
    - x (array-like): The independent variable data.
    - y (array-like): The dependent variable data.
    - unc (array-like with units, optional): The uncertainties associated with the independent variable data. Default is None.

    Returns:
    tuple: A tuple containing the following elements:
        - slope (float): The slope of the fitted linear model.
        - intercept (float): The intercept of the fitted linear model.
        - r2 (float): The R-squared value, indicating the proportion of variance explained by the linear model.
        - corr (float): The Pearson correlation coefficient, measuring the linear correlation between x and y.
    """
    x_data = np.ma.array(x.value, mask=np.isnan(x.value))
    y_data =  np.ma.array(y.value, mask=np.isnan(y.value))
    if unc is None:
        w = None
    else:
        unc = np.ma.array(unc.value, mask=np.isnan(x.value))
        w = 1/unc 
    # initialize a linear fitter
    fit = fitting.LinearLSQFitter()

    # initialize a linear model
    line_init = models.Linear1D()

    # fit the data with the fitter
    fitted_line = fit(line_init, x_data, y_data, weights = w)
    slope = fitted_line.slope.value
    intercept = fitted_line.intercept.value

    # Predict values using the fitted model
    y_pred = fitted_line(x_data)

    # Remove NaN values
    mask = ~np.isnan(y_data) & ~np.isnan(y_pred)
    y_data_clean = y_data[mask]
    y_pred_clean = y_pred[mask]
    mask = ~np.isnan(x_data) 
    x_data_clean = x_data[mask]

    # Calculate R-squared
    r2 = r2_score(y_data_clean, y_pred_clean)

    # Calculate Pearson correlation coefficient
    corr = np.sqrt(np.abs(r2))

    return slope, intercept, r2, corr
```

4.  [Scatter plots]{.underline}: Scatter plots are essential for visually assessing the relationship between two datasets, identifying correlations, trends, and outliers, and evaluating the fit of linear models.

```{python}
def scatter_plot(x, y, xerr = None, yerr = None):
    """
    Generates a scatter plot of two datasets with optional error bars, fits a linear model to the data, 
    and displays the fitted line on the plot.

    Parameters:
    - x (array-like with units): Independent variable data.
    - y (array-like with units): Dependent variable data.
    - xerr (array-like, optional): Error in the independent variable data. Default is 0.
    - yerr (array-like, optional): Error in the dependent variable data. Default is 0.

    Returns:
    None. The function displays a scatter plot with a fitted linear model.
    """
    # Convert data to masked arrays, masking NaN values
    x_data = np.ma.array(x.value, mask=np.isnan(x.value))
    y_data =  np.ma.array(y.value, mask=np.isnan(y.value))

    # Handle default values for xerr and yerr
    if xerr is None:
        xerr_d = 0
    else:
        xerr_d = np.ma.array(xerr.value, mask=np.isnan(xerr))
    if yerr is None:
        yerr_d = 0
    else:
        yerr_d = np.ma.array(yerr.value, mask=np.isnan(yerr))

    
    # Perform linear comparison between the datasets
    if yerr is not None:
        unc = yerr
    elif yerr is None and xerr is not None:
        unc = xerr
    else:
        unc = None
    c, m, r2, corr = compare_data(x, y, unc)

    # Plot the data with error bars
    # errorbar -> needs np.ma -> no units
    plt.errorbar(x_data, y_data, xerr = xerr_d, yerr = yerr_d, alpha = 0.3, c = "blue", label = "Data", fmt=".")
    
    # Plot the fitted line with unit support
    plt.plot(x, c*x + m*x.unit, c = "red", label = f"Fit: {y.info.name}$_H $= {c:.2f}$\cdot${x.info.name}$_L${m:+.2f}\n $R^2=$ {r2:.2f}")

    # Set plot labels
    plt.xlabel(f"LCV, {x.info.name} [{x.unit}]")
    plt.ylabel(f"HECATE, {y.info.name} [{y.unit}]")

    # Display legend
    plt.legend()
    
    # Show the plot
    plt.show()
```

-   Histograms

-   Deviation

# Comparable data

::: panel-tabset
## Coordinates

```{python}
#| echo: false
ra_corr = round(compare_data(dt["Ra_1"],dt["RA_2"])[3],3)
dec_corr = round(compare_data(dt["Dec_1"],dt["DEC_2"])[3],3)
d_corr = round(compare_data(dt["Dis"],dt["D"])[3],3)
```

|  LCV  | HECATE |   Description   | Pearson Correlation \[-1,1\] |
|:-----:|:------:|:---------------:|:----------------------------:|
| Ra_1  |  RA_2  | Right Ascension |      `{python} ra_corr`      |
| Dec_1 | DEC_2  |   Declination   |     `{python} dec_corr`      |
|  Dis  |   D    |    Distance     |      `{python} d_corr`       |

```{python}

scatter_plot(dt["Ra_1"], dt["RA_2"]), scatter_plot(dt["Dec_1"], dt["DEC_2"]), scatter_plot(dt["Dis"], dt["D"])
```

## Velocities

```{python}
rvel_corr = round(compare_data(dt["RVel"],dt["V"])[3],3)
rvel_corr_v = round(compare_data(dt["RVel"],dt["V_VIR"])[3],3)
vlg_corr = round(compare_data(dt["VLG"],dt["V"])[3],3)
vlg_corr_v = round(compare_data(dt["VLG"],dt["V_VIR"])[3],3)
cz_corr = round(compare_data(dt["cz"],dt["V"])[3],3)
cz_corr_v = round(compare_data(dt["cz"],dt["V_VIR"])[3],3)
```

|       LCV        |        HECATE         |         Description          |        Linear Correlation         |
|:----------------:|:-----------------:|:----------------:|:----------------:|
|       RVel       | V/V_VIR (with errors) | Heliocentric radial velocity | `{python} rvel_corr, rvel_corr_v` |
|       VLG        | V/V_VIR (with errors) |       Radial velocity        |  `{python} vlg_corr, vlg_corr_v`  |
| cz (with errors) | V/V_VIR (with errors) |    Heliocentric velocity     |   `{python} cz_corr, cz_corr_v`   |

```{python}
scatter_plot(dt["RVel"], dt["V"], yerr = dt["E_V"])
```

## Morphology and Geometry

```{python}
#| echo: false
 
ttype_corr = round(compare_data(dt["TType"], dt["T"])[3], 4)
inc_corr = round(compare_data(dt["inc"], dt["I"])[3], 3)
#a26_corr = round(compare_data(dt["a26_1"], dt["R1"])[3], 3)
#it doesnt even compute
```

|      LCV      |        HECATE        |                        Description                        | Pearson Correlation \[-1,1\] |
|:---------------:|:---------------:|:-------------------:|:---------------:|
|     TType     |   T (with errors)    | Numerical Hubble type following the de Vaucouleurs system |    `{python} ttype_corr`     |
|      inc      |          I           |                     Inclination (deg)                     |     `{python} inc_corr`      |
| a26_1 (Major) | R1 (Semi-major axis) |                 angular diameter (arcmin)                 |              0               |

As we can see we don't have any significant correlation between the data

```{python}

dt["TType"].info, dt["T"].info
```

## Luminosities

|   LCV   | HECATE | Description |
|:-------:|:------:|:-----------:|
| logKLum | logL_K |             |
|         |        |             |
|         |        |             |

## Magnitudes

|         LCV         | HECATE | Description |
|:-------------------:|:------:|:-----------:|
| mag_B (with errors) |        |             |
|       mag_FUV       |        |             |
|                     |        |             |

## Absorbsion

|  LCV   | HECATE |                  Description                   |
|:------:|:------:|:----------------------------------------------:|
|   AB   |   AG   |    Galactic extinction/absorption in B band    |
| AB_int |   AI   | Internal/Intrisic B band extinction/absorption |

## SFR

|  LCV   |   HECATE   |                           Description                            |
|:------------------:|:------------------:|:------------------------------:|
|        | logSFR_TIR | Decimal logarithm of the total-infrared SFR estimate \[Msol/yr\] |
|        | logSFR_FIR |  Decimal logarithm of the far-infrared SFR estimate \[Msol/yr\]  |
|        | logSFR_60u |      Decimal logarithm of the 60um SFR estimate \[Msol/yr\]      |
|        | logSFR_12u |      Decimal logarithm of the 12um SFR estimate \[Msol/yr\]      |
|        | logSFR_22u |      Decimal logarithm of the 22um SFR estimate \[Msol/yr\]      |
|        | logSFR_HEC |  Decimal logarithm of the homogenised SFR estimate \[Msol/yr\]   |
|        | logSFR_GSW |       Decimal logarithm of the SFR in GSWLC-2 \[Msol/yr\]        |
| SFRFUV |            |             FUV derived integral star formation rate             |
| SFRHa  |            |          H{alpha} derived integral star formation rate           |

## Masses

|      LCV       |  HECATE  |                        Description                        |
|:------------------:|:------------------:|:------------------------------:|
|     logM26     |          |              Log mass within Holmberg radius              |
|     logMHI     |          |              Log mass within Holmberg radius              |
|                | logM_HEC |      Decimal logarithm of the stellar mass \[Msol\]       |
|                | logM_GSW | Decimal logarithm of the stellar mass in GSWLC-2 \[Msol\] |
| logStellarMass |          |                Stellar Mass from M\*/L=0.6                |
:::