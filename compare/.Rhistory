#| echo: false
import numpy as np
import matplotlib.pyplot as plt
from sklearn.metrics import r2_score
from astropy.io import ascii
from astropy.coordinates import SkyCoord
from astropy.table import Table, join, QTable
import astropy.units as u
from astropy.visualization import quantity_support
#quantity_support()
from astropy.modeling import models, fitting
from scipy.stats import pearsonr
import glob
import os
plt.style.use('ggplot')
dt = QTable(ascii.read("../tables/inner_join.ecsv"), masked=True)
def compare_data(x, y, unc=None, sigma = None):
"""
Performs a linear comparison between two datasets.
This function fits a linear model to the data, calculates the slope and intercept of the fitted line,
and computes the R-squared value and Pearson correlation coefficient to assess the fit quality.
Parameters:
- x (array-like): The independent variable data.
- y (array-like): The dependent variable data.
- unc (array-like with units, optional): The uncertainties associated with the independent variable data. Default is None.
Returns:
tuple: A tuple containing the following elements:
- slope (float): The slope of the fitted linear model.
- intercept (float): The intercept of the fitted linear model.
- r2 (float): The R-squared value, indicating the proportion of variance explained by the linear model.
- corr (float): The Pearson correlation coefficient, measuring the linear correlation between x and y.
"""
try:
x_data = np.ma.array(x.value, mask=np.isnan(x.value))
y_data = np.ma.array(y.value, mask=np.isnan(y.value))
if unc is None:
w = None
else:
unc = np.ma.array(unc.value, mask=np.isnan(x.value))
w = 1 / unc
# initialize a linear fitter
fit = fitting.LinearLSQFitter()
# initialize a linear model
line_init = models.Linear1D()
# fit the data with the fitter
# check if sigma
if sigma is None:
fitted_line = fit(line_init, x_data, y_data, weights=w)
outliers = None
else:
or_fit = fitting.FittingWithOutlierRemoval(fit, sigma_clip, niter=3, sigma=sigma)
fitted_line, outliers = or_fit(line_init, x, y, weights=w)
slope = fitted_line.slope.value
intercept = fitted_line.intercept.value
# Predict values using the fitted model
y_pred = fitted_line(x_data)
# Remove NaN values
mask = ~np.isnan(y_data) & ~np.isnan(y_pred)
y_data_clean = y_data[mask]
y_pred_clean = y_pred[mask]
mask = ~np.isnan(x_data)
x_data_clean = x_data[mask]
# Calculate R-squared
r2 = r2_score(y_data_clean, y_pred_clean)
# Calculate Pearson correlation coefficient
corr = np.sqrt(np.abs(r2))
return slope, intercept, r2, corr, outliers
except Exception:
return 0, 0, 0, 0, None
def scatter_plot(x, y, xerr = None, yerr = None, sigma = None):
"""
Generates a scatter plot of two datasets with optional error bars, fits a linear model to the data,
and displays the fitted line on the plot.
Parameters:
- x (array-like with units): Independent variable data.
- y (array-like with units): Dependent variable data.
- xerr (array-like, optional): Error in the independent variable data. Default is 0.
- yerr (array-like, optional): Error in the dependent variable data. Default is 0.
Returns:
None. The function displays a scatter plot with a fitted linear model.
"""
# Convert data to masked arrays, masking NaN values
x_data = np.ma.array(x.value, mask=np.isnan(x.value))
y_data =  np.ma.array(y.value, mask=np.isnan(y.value))
# Handle default values for xerr and yerr
if xerr is None:
xerr_d = 0
else:
xerr_d = np.ma.array(xerr.value, mask=np.isnan(xerr))
if yerr is None:
yerr_d = 0
else:
yerr_d = np.ma.array(yerr.value, mask=np.isnan(yerr))
# Perform linear comparison between the datasets
if yerr is not None:
unc = yerr
elif yerr is None and xerr is not None:
unc = xerr
else:
unc = None
c, m, r2, corr, outliers = compare_data(x, y, unc, sigma)
# Plot the data with error bars
# errorbar -> needs np.ma -> no units
if outliers is not None:
filtered_data = np.ma.masked_array(y_data, mask = outlier)
plt.errorbar(x, y, yerr=yunc, fillstyle="none", c = "black", label="Clipped Data")
plt.plot(x, filtered_data,  label="Fitted Data", c = "blue")
else:
plt.errorbar(x_data, y_data, xerr = xerr_d, yerr = yerr_d, alpha = 0.3, c = "blue", label = "Data")
# Plot the fitted line
if c!=0:
plt.plot(x, c*x.value+ m, c = "red", label = f"Fit: {y.info.name}$_H $= {c:.2f}$\cdot${x.info.name}$_L${m:+.2f}\n $R^2=$ {r2:.2f}")
# Set plot labels
plt.xlabel(f"LCV, {x.info.name} [{x.unit}]")
plt.ylabel(f"HECATE, {y.info.name} [{y.unit}]")
# Display legend
plt.legend()
# Show the plot
plt.show()
#| echo: false
ra_corr = round(compare_data(dt["Ra_1"],dt["RA_2"])[3],3)
dec_corr = round(compare_data(dt["Dec_1"],dt["DEC_2"])[3],3)
d_corr = round(compare_data(dt["Dis"],dt["D"])[3],3)
scatter_plot(dt["Ra_1"], dt["RA_2"]), scatter_plot(dt["Dec_1"], dt["DEC_2"]), scatter_plot(dt["Dis"], dt["D"])
rvel_corr = round(compare_data(dt["RVel"],dt["V"])[3],3)
rvel_corr_v = round(compare_data(dt["RVel"],dt["V_VIR"])[3],3)
vlg_corr = round(compare_data(dt["VLG"],dt["V"])[3],3)
vlg_corr_v = round(compare_data(dt["VLG"],dt["V_VIR"])[3],3)
cz_corr = round(compare_data(dt["cz"],dt["V"])[3],3)
cz_corr_v = round(compare_data(dt["cz"],dt["V_VIR"])[3],3)
scatter_plot(dt["RVel"], dt["V"], yerr = dt["E_V"])
#| echo: false
ttype_corr = round(compare_data(dt["TType"], dt["T"])[3], 4)
inc_corr = round(compare_data(dt["inc"], dt["INCL"])[3], 3)
a26_corr = round(compare_data(dt["a26_1"], dt["A26_1a"])[3], 3)
scatter_plot(dt["TType"], dt["T"], yerr = dt["E_T"])
scatter_plot(dt["inc"], dt["INCL"], yerr = dt["E_V"])
scatter_plot(dt["a26_1"], dt["A26_1a"], yerr = dt["E_V"])
#| echo: false
logKLum_corr = round(compare_data(dt["logKLum"], dt["logL_K"])[3], 3)
scatter_plot(dt["logKLum"], dt["logL_K"])
#| echo: false
mag_B_corr = round(compare_data(dt["mag_B"], dt["BT"],unc = dt["E_BT"])[3], 3)
Kmag_corr = round(compare_data(dt["Kmag"], dt["K"], unc = dt["E_K"])[3], 3)
scatter_plot(dt["mag_B"], dt["BT"], yerr = dt["E_BT"])
scatter_plot(dt["Kmag"], dt["K"], yerr = dt["E_K"])
#| echo: false
ab_corr = round(compare_data(dt["AB"], dt["AG"])[3], 3)
#ab_int_corr = round(compare_data(dt["AB_int"], dt["AI"])[3], 3)
scatter_plot(dt["AB"], dt["AG"])#, scatter_plot(dt["AB_int"], dt["AI"])
#| echo: false
import numpy as np
import matplotlib.pyplot as plt
from sklearn.metrics import r2_score
from astropy.io import ascii
from astropy.coordinates import SkyCoord
from astropy.table import Table, join, QTable
import astropy.units as u
from astropy.visualization import quantity_support
#quantity_support()
from astropy.modeling import models, fitting
from scipy.stats import pearsonr
import glob
import os
plt.style.use('ggplot')
dt = QTable(ascii.read("../tables/inner_join.ecsv"), masked=True)
def compare_data(x, y, unc=None, sigma = None):
"""
Performs a linear comparison between two datasets.
This function fits a linear model to the data, calculates the slope and intercept of the fitted line,
and computes the R-squared value and Pearson correlation coefficient to assess the fit quality.
Parameters:
- x (array-like): The independent variable data.
- y (array-like): The dependent variable data.
- unc (array-like with units, optional): The uncertainties associated with the independent variable data. Default is None.
Returns:
tuple: A tuple containing the following elements:
- slope (float): The slope of the fitted linear model.
- intercept (float): The intercept of the fitted linear model.
- r2 (float): The R-squared value, indicating the proportion of variance explained by the linear model.
- corr (float): The Pearson correlation coefficient, measuring the linear correlation between x and y.
"""
try:
x_data = np.ma.array(x.value, mask=np.isnan(x.value))
y_data = np.ma.array(y.value, mask=np.isnan(y.value))
if unc is None:
w = None
else:
unc = np.ma.array(unc.value, mask=np.isnan(x.value))
w = 1 / unc
# initialize a linear fitter
fit = fitting.LinearLSQFitter()
# initialize a linear model
line_init = models.Linear1D()
# fit the data with the fitter
# check if sigma
if sigma is None:
fitted_line = fit(line_init, x_data, y_data, weights=w)
outliers = None
else:
or_fit = fitting.FittingWithOutlierRemoval(fit, sigma_clip, niter=3, sigma=sigma)
fitted_line, outliers = or_fit(line_init, x, y, weights=w)
slope = fitted_line.slope.value
intercept = fitted_line.intercept.value
# Predict values using the fitted model
y_pred = fitted_line(x_data)
# Remove NaN values
mask = ~np.isnan(y_data) & ~np.isnan(y_pred)
y_data_clean = y_data[mask]
y_pred_clean = y_pred[mask]
mask = ~np.isnan(x_data)
x_data_clean = x_data[mask]
# Calculate R-squared
r2 = r2_score(y_data_clean, y_pred_clean)
# Calculate Pearson correlation coefficient
corr = np.sqrt(np.abs(r2))
return slope, intercept, r2, corr, outliers
except Exception:
return 0, 0, 0, 0, None
def scatter_plot(x, y, xerr = None, yerr = None, sigma = None):
"""
Generates a scatter plot of two datasets with optional error bars, fits a linear model to the data,
and displays the fitted line on the plot.
Parameters:
- x (array-like with units): Independent variable data.
- y (array-like with units): Dependent variable data.
- xerr (array-like, optional): Error in the independent variable data. Default is 0.
- yerr (array-like, optional): Error in the dependent variable data. Default is 0.
Returns:
None. The function displays a scatter plot with a fitted linear model.
"""
# Convert data to masked arrays, masking NaN values
x_data = np.ma.array(x.value, mask=np.isnan(x.value))
y_data =  np.ma.array(y.value, mask=np.isnan(y.value))
# Handle default values for xerr and yerr
if xerr is None:
xerr_d = 0
else:
xerr_d = np.ma.array(xerr.value, mask=np.isnan(xerr))
if yerr is None:
yerr_d = 0
else:
yerr_d = np.ma.array(yerr.value, mask=np.isnan(yerr))
# Perform linear comparison between the datasets
if yerr is not None:
unc = yerr
elif yerr is None and xerr is not None:
unc = xerr
else:
unc = None
c, m, r2, corr, outliers = compare_data(x, y, unc, sigma)
# Plot the data with error bars
# errorbar -> needs np.ma -> no units
if outliers is not None:
filtered_data = np.ma.masked_array(y_data, mask = outlier)
plt.errorbar(x, y, yerr=yunc, fillstyle="none", c = "black", label="Clipped Data", fmt = ".")
plt.scatter(x, filtered_data,  label="Fitted Data", c = "blue")
else:
plt.errorbar(x_data, y_data, xerr = xerr_d, yerr = yerr_d, alpha = 0.3, c = "blue", label = "Data", fmt = ".")
# Plot the fitted line
if c!=0:
plt.plot(x, c*x.value+ m, c = "red", label = f"Fit: {y.info.name}$_H $= {c:.2f}$\cdot${x.info.name}$_L${m:+.2f}\n $R^2=$ {r2:.2f}")
# Set plot labels
plt.xlabel(f"LCV, {x.info.name} [{x.unit}]")
plt.ylabel(f"HECATE, {y.info.name} [{y.unit}]")
# Display legend
plt.legend()
# Show the plot
plt.show()
#| echo: false
ra_corr = round(compare_data(dt["Ra_1"],dt["RA_2"])[3],3)
dec_corr = round(compare_data(dt["Dec_1"],dt["DEC_2"])[3],3)
d_corr = round(compare_data(dt["Dis"],dt["D"])[3],3)
scatter_plot(dt["Ra_1"], dt["RA_2"]), scatter_plot(dt["Dec_1"], dt["DEC_2"]), scatter_plot(dt["Dis"], dt["D"])
rvel_corr = round(compare_data(dt["RVel"],dt["V"])[3],3)
rvel_corr_v = round(compare_data(dt["RVel"],dt["V_VIR"])[3],3)
vlg_corr = round(compare_data(dt["VLG"],dt["V"])[3],3)
vlg_corr_v = round(compare_data(dt["VLG"],dt["V_VIR"])[3],3)
cz_corr = round(compare_data(dt["cz"],dt["V"])[3],3)
cz_corr_v = round(compare_data(dt["cz"],dt["V_VIR"])[3],3)
scatter_plot(dt["RVel"], dt["V"], yerr = dt["E_V"])
#| echo: false
ttype_corr = round(compare_data(dt["TType"], dt["T"])[3], 4)
inc_corr = round(compare_data(dt["inc"], dt["INCL"])[3], 3)
a26_corr = round(compare_data(dt["a26_1"], dt["A26_1a"])[3], 3)
scatter_plot(dt["TType"], dt["T"], yerr = dt["E_T"])
scatter_plot(dt["inc"], dt["INCL"], yerr = dt["E_V"])
scatter_plot(dt["a26_1"], dt["A26_1a"], yerr = dt["E_V"])
#| echo: false
logKLum_corr = round(compare_data(dt["logKLum"], dt["logL_K"])[3], 3)
scatter_plot(dt["logKLum"], dt["logL_K"])
#| echo: false
mag_B_corr = round(compare_data(dt["mag_B"], dt["BT"],unc = dt["E_BT"])[3], 3)
Kmag_corr = round(compare_data(dt["Kmag"], dt["K"], unc = dt["E_K"])[3], 3)
scatter_plot(dt["mag_B"], dt["BT"], yerr = dt["E_BT"])
scatter_plot(dt["Kmag"], dt["K"], yerr = dt["E_K"])
#| echo: false
ab_corr = round(compare_data(dt["AB"], dt["AG"])[3], 3)
#ab_int_corr = round(compare_data(dt["AB_int"], dt["AI"])[3], 3)
scatter_plot(dt["AB"], dt["AG"])#, scatter_plot(dt["AB_int"], dt["AI"])
reticulate::repl_python()
