#+title:Investigations of the galaxies in the LCV
#+subtitle: Finding the normalization constant of $SFR_{del}$ and the relations between the parameters of the Galaxies
#+author: Dimitrios Papachistopoulos
#+PROPERTY: header-args :lang python :eval python :exports results :tangle final.py :comments both :results output :session main_paper

:latex_prop:
#+OPTIONS: toc:nil
#+LaTeX_CLASS_OPTIONS: [a4paper]
#+LaTeX_HEADER: \usepackage{breakcites}
#+LaTeX_HEADER: \usepackage{paralist}
#+LaTeX_HEADER: \usepackage{amsmath}
#+LaTeX_HEADER: \usepackage{biblatex}
#+LaTeX_HEADER: \usepackage{hyperref}
#+LaTeX_HEADER: \usepackage{graphicx}
#+LaTeX_HEADER: \usepackage{caption}
#+LaTeX_HEADER: \usepackage{booktabs}
#+LaTeX_HEADER: \usepackage[T1]{fontenc}
#+LaTeX_HEADER: \usepackage{tgbonum}
#+LaTeX_HEADER: \let\itemize\compactitem
#+LaTeX_HEADER: \let\description\compactdesc
#+LaTeX_HEADER: \let\enumerate\compactenum
#+OPTIONS: tex:imagemagick
#+bibliography:My Library.bib
:end:

#+begin_src python :results none
import numpy as np
import numpy.ma as ma
import pandas as pd
from astropy.io import ascii
from astropy.table import Table, QTable, join, hstack, vstack, unique, Column, MaskedColumn, setdiff
from astropy.utils.masked import Masked
from astropy.coordinates import SkyCoord, Galactic, Angle
from astropy.time import Time
import astropy.units as u
from astropy.utils.diff import report_diff_values
from astropy.visualization import quantity_support, hist
quantity_support()
import glob as glob
import sys
import matplotlib.pyplot as plt
from plotnine import (
    ggplot,qplot, ggsave, aes,
    after_stat,
    stage,
    geom_point, geom_smooth, geom_qq, geom_bar, geom_text, geom_label,
    position_dodge2,
    facet_wrap,
    labs,
    scale_x_continuous, scale_x_log10, scale_y_log10,
    xlim, ylim,
    stat_qq
)
from scipy import optimize, stats
from sympy import symbols, exp, log, lambdify
import seaborn as sns
import plotly.express as px

#+end_src

#+begin_src python :results none
dt = QTable.read("./tables/final_table.ecsv")

#+end_src

#+begin_src python :results none

sns.set_theme(style="darkgrid",context = "notebook", palette="deep")
#+end_src

#+begin_abstract
The paper investigates the properties of galaxies in the Local Cosmological Volume (LCV), using the Catalogue of Neighboring Galaxies[cite:@karachentsevUPDATEDNEARBYGALAXY2013] and its updated version from the "Catalog & Atlas of the LV galaxies" database[cite:@CatalogLVGalaxies]. The properties studied include the galaxy types, their various masses, the star formation rates (SFRs) and the star formation timescale $\tau$, gas depletion timescale $\tau_g$ and the star formation time $t_{sf}$. The paper aims to understand the distribution and correlation of these properties in the sample of galaxies in the LCV, and how they relate to current astrophysical theories.
#+end_abstract

* The Galaxies in the Local Cosmological Volume (LCV)

The Catalogue of Neigbouring Galaxies (Karachentsev, Igor D. and Makarov  et al. 2013[cite:@karachentsevUPDATEDNEARBYGALAXY2013]) and its updated version from the "Catalog & Atlas of the LV galaxies" databas[cite:@CatalogLVGalaxies]  are used to extract the K-band luminosities, the types of the galaxies, the mass within the Holmberg radius (M26), the Hydrogen masses of the galaxies ($M_{HI}$) and the SFRs based on integrated  H and far-ultraviolet (FUV) measurments for galaxies within a distance of $\approx 11$ Mpc.

** How are the galaxies chosen

According to [cite:@kraan-kortewegCatalogueGalaxiesIo1979] the Local Cosmological Volume is defined as the galaxies inside the radius of 10 Mpc and having radial velocities with respect to centroid of the Local Group $V_{lg} \le 500 \, km \cdot s^{-1}$. However, this assumed a Hubble constant of $H_0 = 50\, km \cdot s^{-1}$.

1. *Initial Selection Criteria*: Galaxies within a 10 Mpc radius were initially selected based on a radial velocity limit (VLG) of 500 km/s, considering a Hubble parameter (H0) of 50 km/s/Mpc.

2. *Updated Criteria*: To accommodate the revised H0 value of 73 km/s/Mpc, the VLG limit needs to be raised to 730 km/s.

3. *Local Velocity Field*: The presence of the Virgo cluster and the Local Void introduces additional velocity components, complicating distance estimation based solely on radial velocities.

4. *Peculiar Motions*: Collective motions within large-scale structures can introduce peculiar velocities, complicating distance estimation.

5. *Distance Measurement Methods*: Direct distance measurements using methods like the tip of the red giant branch (TRGB) provide accurate distances but are resource-intensive, requiring extensive observation time with instruments like the Hubble Space Telescope (HST).

6. *Inclusion Criteria*: Galaxies are included based on either radial velocities or distance estimates, considering the limitations and uncertainties in both methods.

7. *Extension to 11 Mpc*: Galaxies with distance estimates beyond 10 Mpc may still be included due to uncertainties in distance measurements and the potential influence of coherent motions and large-scale structures.

8. *Sample Composition*: The LV sample comprises src_python[:results value org]{len(dt)} {{{results(src_org{1448})}}} galaxies, with considerations for galaxies near the boundaries of the selection criteria and the potential influence of measurement errors.

   #+begin_src python :results file drawer value
hubble = (ggplot(dt.to_pandas())
          + aes( x = "Dis", y =  "VLG")
          + labs( x = f"Distance [{dt['Dis'].unit}]" , y = "Radial velocities $V_{LG} $"+f"[{dt['VLG'].unit:latex}]" )
          + xlim(0,11) + ylim(0,1200)
          + geom_smooth(color = "red")
          + geom_point()
          )
fname = "figure/hubble.png"
hubble.save(fname)
fname
#+end_src

   #+RESULTS:
   :results:
   [[file:figure/hubble.png]]
   :end:


** Mapping the galaxies

Because matplotlib needs the coordinates in radians and between $-\pi$ and $\pi$
and, not 0 and $2\pi$, we have to convert coordinates.

#+begin_src python :results value file drawer
filename = "figure/mapping"

# Assuming dt is your data table containing coordinates, mass, and distance
c = dt["Coordinates"]
mass = dt["M26"].data  # Assuming mass is provided in some unit
distance = dt["Dis"].data  # Assuming distance is provided in some unit

# Extract Galactic Coordinates
galactic_coords = c.galactic

# Extract Equatorial Coordinates
equatorial_coords = c.transform_to('icrs')

# Define the size and color based on mass and distance
marker_size = np.sqrt(mass) * 0.0002  # Adjust scaling factor as needed
marker_color = distance   # Use distance directly for marker color

# Plot Galactic Coordinates
plt.figure(figsize=(8, 8))
plt.subplot(211, projection="aitoff")
plt.grid(True)
plt.scatter(galactic_coords.l.wrap_at(180 * u.deg).radian, galactic_coords.b.radian, s=marker_size, c=marker_color, cmap='viridis')
plt.colorbar(label='Distance [{}]'.format(dt['Dis'].unit))  # Add colorbar for distance
plt.title("Galactic Coordinates")

# Plot Equatorial Coordinates
plt.subplot(212, projection="mollweide")
plt.grid(True)
plt.scatter(equatorial_coords.ra.wrap_at(180 * u.deg).radian, equatorial_coords.dec.radian, s=marker_size, c=marker_color, cmap='viridis')
plt.colorbar(label='Distance [{}]'.format(dt['Dis'].unit))  # Add colorbar for distance
plt.title("Equatorial Coordinates")


plt.suptitle("Galaxies of the LCV with Mass and Distance Representation")

plt.tight_layout()  # Adjust spacing between subplots
plt.savefig(filename)
plt.close()

filename+".png"
#+end_src

#+RESULTS:
:results:
[[file:figure/mapping.png]]
:end:


** Types of galaxies

Using the dataset of src_python[:results value org :exports results]{len(dt)} {{{results(src_org{1448})}}}
galaxies, we can study the morphology of the galaxies in the LCV

*** Morphology
#+name: morphology
#+begin_src python :results value drawer :var x = "TType" file = "Types" label = "Morphology type code"
x="TType"
file="Types"
label="Morphology type code"
dttype = pd.DataFrame({"x": dt["{}".format(x)]}).dropna()
morphology = (
    ggplot(dttype, aes("factor(x)"))
    + geom_bar(color="black", fill="#1f77b4", show_legend=False)
    + geom_text(
        aes(label=after_stat("count")),
        stat="count",
        nudge_y=15,
        va="bottom",
        size = 9
    )
    + geom_text(
        aes(label=after_stat("prop*100"), group=1),
        stat="count",
        va="bottom",
        format_string="({:.1f}%)",
        size = 6
    )
    + labs(x = "{}".format(label))
)
fname = "figure/{}.png".format(file)
morphology.save(fname)

"[[./"+fname+"]]"
#+end_src

#+RESULTS: morphology
:results:
[[./figure/Types.png]]
:end:






**** Morphology of dwarf galaxies


#+call: morphology[:results value drawer](x = "Tdw1", file = "Tdw1", label = "Morphology of dwarf galaxies")

#+RESULTS:
:results:
[[./figure/Types.png]]
:end:



**** Dwarf galaxy surface brightness morphology

#+call: morphology[:results value drawer](x = "Tdw2", file = "Tdw2", label = "Dwarf galaxy surface brightness morphology")

#+RESULTS:
:results:
[[./figure/Types.png]]
:end:


* Understanding the Data

The catalog consists of 8 tables

1. Catalog of Nearby Galaxies
2. Global Parameters of the Nearby Galaxies
3. List of Apparent Magnitudes
4. List of Heliocentric Velocities
5. List of Inner Kinematics
6. List of Distances
7. List of the nearby galaxies with measured SFR
8. List of Bibliographic References

We want several measurments from those lists so we will join them according to the name of the galaxy.

This catalog consists of src_python[:results value org]{len(dt)+1} {{{results(src_org{1449})}}} galaxies

** Understanding the limit flags

Some of those values contain limit flags, which we will mask for our present analysis. However, those values will be shown in the plots, and afterwards will be compared with the theoretical values.

The limit flags are placed in values, were the uncertainty of the value is high, usualy because of how accurate the measurement is (way to high or low)

#+begin_src python :exports none
for column in dt.columns:
    if column.startswith("l_") or column.startswith("f_"):
        if column.startswith("l_"):
            corresponding_column_name = column[2:]  # Remove the 'l_' prefix
        else:
            corresponding_column_name = column[2:]  # Remove the 'f_' prefix

        try:
            all_masks_in_corresponding = all(mask in dt[corresponding_column_name].mask for mask in dt[column].mask)
            if all_masks_in_corresponding:
                print(f"All masks in {column} are also masks in {corresponding_column_name}")
            else:
                print(f"Not all masks in {column} are masks in {corresponding_column_name}")
        except AttributeError:
            print(f"We have no mask for {column}")
#+end_src

#+RESULTS:
#+begin_example
All masks in l_FUVmag are also masks in FUVmag
All masks in l_Hamag are also masks in Hamag
All masks in f_Kmag are also masks in Kmag
All masks in l_21mag are also masks in 21mag
We have no mask for f_Dis
All masks in l_logMHI are also masks in logMHI
All masks in l_mag_B are also masks in mag_B
All masks in l_mag_FUV are also masks in mag_FUV
All masks in l_mag_HI are also masks in mag_HI
All masks in l_mag_Ha are also masks in mag_Ha
All masks in l_mag_Ks are also masks in mag_Ks
All masks in l_SFRHa are also masks in SFRHa
All masks in l_PHa are also masks in PHa
All masks in l_FHa are also masks in FHa
All masks in l_SFRFUV are also masks in SFRFUV
All masks in l_PFUV are also masks in PFUV
All masks in l_FFUV are also masks in FFUV
#+end_example





** P and F evolutionary parameters

"To characterize the evolutionary status of a sample of galaxies, Karachentsev & Kaisin (2007) proposed a diagnostic ‚Äúpast‚Äìfuture‚Äù (PF) diagram, where the dimensionless parameters

$$ P = \log{(SFR\cdot T_0/L_K)}$$
$$ F = \log{(1.85 M_{HI}/SFR\cdot T_0)}$$

are independent from errors in finding distances to the galaxies. The parameter P is actually the sSFR over the entire age scale of the universe, T0 = 13.7 Gyr. The F parameter corresponds to the notion of gas depletion time, expressed in units of T0."[cite:@karachentsevSTARFORMATIONPROPERTIES2013a]

* Standarized constants

We should use some standart consistent values for our analysis.

1. According to [cite:@speagleHighlyConsistentFramework2014] and[cite:@kroupaConstraintsStarFormation2020] the $t_{sf} = 12\, Gyr$ represents a strong and consistent constraint of galaxy evolution, across many studies. While other researchers adopt a t_{sf}= 13.6 Gyr[cite:@haslbauerCosmologicalStarFormation2023], we use the 12 Gyr assumption following the framework of SP14
2. $\zeta =$ accommodates mass-loss through stellar evolution. According to the IGIMF theory the galaxies of the the LCV are expected to have 1< $\zeta$ <1.3, so by adopting $\zeta =1.3$ we are working conservatively
3. Main Sequence z = 5

#+begin_src python :results none
t_sf = 12 * u.Gyr
zeta = 1.3
z = 5
#+end_src


* Calculations for values that we need


** Total stellar masses, the total gas mass and total barionic of the galaxies

The $MHI$ can be converted to the total mass of the gas of the galaxy using the equation $M_g=1.33\, MHI$


#+begin_src python :exports none
dt["M_g"] = 1.33 * dt["MHI"]
dt["M_g"].info()
#+end_src

#+RESULTS:
: name = M_g
: dtype = float64
: unit = solMass
: description = Linear hydrogen mass
: class = MaskedQuantity
: n_bad = 501
: length = 1448

The K-band values are converted to the total Stellar Masses of each galaxy according to the mass-to-light ratio of 0.6 ($M_\odot/Lum$)[cite:@lelliSPARCMASSMODELS2016]

#+begin_src python
dt["StellarMass"] = 0.6 * dt["KLum"]* u.Msun/u.solLum
dt["StellarMass"].description = "K-band luminosity using a mass-to-light ratio of 0.6"
dt["StellarMass"].info()
#+end_src

#+RESULTS:
: name = StellarMass
: dtype = float64
: unit = solMass
: description = Linear K_S_ band luminosity
: class = MaskedQuantity
: n_bad = 12
: length = 1448

The total barionic mass can be calcuated as the sum of the total gas mass of the galaxy with the Stellar mass

#+begin_src python
dt["BarMass"] = dt["M_g"] + dt["StellarMass"]
dt["BarMass"].info()
#+end_src

#+RESULTS:
: name = BarMass
: dtype = float64
: unit = solMass
: description = Linear hydrogen mass
: class = MaskedQuantity
: n_bad = 513
: length = 1448

*** Ratio of M_g and StellarMass

#+begin_src python
dt["mass_ratio"] = dt["M_g"] / dt["StellarMass"]
dt["mass_ratio"].info(["attributes", "stats"])
#+end_src

#+RESULTS:
#+begin_example
/home/dp/.local/lib/python3.10/site-packages/astropy/utils/masked/core.py:879: RuntimeWarning: divide by zero encountered in divide
name = mass_ratio
dtype = float64
description = Linear hydrogen mass
class = MaskedQuantity
mean = 2.13272
std = 3.81136
min = 7.51105e-05
max = 58.3043
n_bad = 513
length = 1448
#+end_example

Histogram of dt["mass_ratio"]

#+begin_src python
#seaborn plot of mass_ratio
sns.histplot(dt["mass_ratio"].value)
plt.xscale("log")
plt.show()
#+end_src

#+RESULTS:

** Color index

Here we calculate the color indexes <FUV-B>

#+begin_src python

dt["color"] = dt["FUVmag"]-dt["Bmag"]

#+end_src

#+RESULTS:

The lower the value, the bluer the stars, thus the younger the star populations

#+begin_src python :results value file drawer
#hist
hist(dt["color"], bins = "freedman")
plt.xlabel("Color index")
plt.ylabel("Number of stars")
plt.title("Color index <FUV - B> distribution")
#save
plt.savefig("figure/color_index.png")
plt.close()
#print in org
"./figure/color_index.png"
#+end_src

#+RESULTS:
:results:
[[file:./figure/color_index.png]]
:end:

** Fixing the SFRs


*** SFR units

#+begin_src python :results none
SFR_unit = u.Msun/u.year
#+end_src

#+RESULTS:
: None
*** log to linear

they are the power in logarithmic scale. SO lets fix them


#+begin_src python
dt.rename_column("SFRFUV", "logSFRFUV")
#+end_src

#+RESULTS:


#+begin_src python
# Calculate SFRFUV from logSFRFUV using np.power
sfr_ha_values = np.power(10, dt["logSFRFUV"]) * SFR_unit

# Create a MaskedColumn for SFRFUV, inheriting the mask and description from logSFRFUV
dt["SFRFUV"] = MaskedColumn(sfr_ha_values, mask=dt["logSFRFUV"].mask, description=dt["logSFRFUV"].description)

# Display statistical information about SFRFUV
dt["SFRFUV"].info("stats")

#+end_src

#+RESULTS:
: name = SFRFUV
: mean = 0.0738724 solMass / yr
: std = 0.349917 solMass / yr
: min = 2.13796e-10 solMass / yr
: max = 5.7544 solMass / yr
: n_bad = 321
: length = 1448

#+begin_src python
dt.rename_column("SFRHa", "logSFRHa")
#+end_src

#+RESULTS:

#+begin_src python
# Calculate SFRHa from logSFRHa using np.power
sfr_ha_values = np.power(10, dt["logSFRHa"]) * SFR_unit

# Create a MaskedColumn for SFRHa, inheriting the mask and description from logSFRHa
dt["SFRHa"] = MaskedColumn(sfr_ha_values, mask=dt["logSFRHa"].mask, description=dt["logSFRHa"].description)

# Display statistical information about SFRHa
dt["SFRHa"].info()
#+end_src

#+RESULTS:
: name = SFRHa
: dtype = float64
: unit = solMass / yr
: description = H{alpha} derived integral star formation rate (1)
: class = MaskedQuantity
: n_bad = 712
: length = 1448

#+begin_src python

dt[["SFRFUV", 'SFRHa']].info(["stats"])
#+end_src

#+RESULTS:
: <QTable length=1448>
:  name           mean                   std                    min                    max         n_bad
: ------ ---------------------- --------------------- ------------------------ ------------------- -----
: SFRFUV 0.0738724 solMass / yr 0.349917 solMass / yr 2.13796e-10 solMass / yr 5.7544 solMass / yr   321
:  SFRHa  0.116644 solMass / yr 0.408421 solMass / yr 1.38038e-10 solMass / yr 4.2658 solMass / yr   712


** SFR_0



Now we have to calculate the total SFR from the equation:

$$
    SFR_o=\frac{SFR_{FUV}+SFR_{Ha}}{2}
$$

if we have both the SFR. If we only have one of them then:

$$
    SFR_{0}=SFR_{i},\ \text{if } SFR_{j}=0,\ i\neq j,\ i,j=SFR_{FUV},\, SFR_{Ha}
$$

#+begin_src python :results drawer output
sns.lmplot(data = dt.to_pandas(), x="SFRHa",y="SFRFUV")
#labels in latex with units
plt.xlabel(r"$SFR_{Ha}$"+r" [{}]".format(dt["SFRHa"].unit.to_string("latex")))
plt.ylabel(r"$SFR_{FUV}$"+r" [{}]".format(dt["SFRHa"].unit.to_string("latex")))

#save
plt.savefig("figure/SFR_FUV-Ha.png")
plt.close()


sns.lmplot(data = dt.to_pandas(), x="logSFRHa",y="logSFRFUV")
#labels in latex with units
plt.xlabel(r"$\log_{10}(SFR_{Ha}$"+r"/ [{}])".format(dt["SFRHa"].unit.to_string("latex")))
plt.ylabel(r"$\log_{10}(SFR_{FUV}$"+r"/ [{}])".format(dt["SFRHa"].unit.to_string("latex")) )

#save
plt.savefig("figure/log_SFR_FUV_Ha.png")
plt.close()
#print in org
print("[[./figure/SFR_FUV-Ha.png]]")
print("[[./figure/log_SFR_FUV_Ha.png]]")
#+end_src

#+RESULTS:
:results:
[[./figure/SFR_FUV-Ha.png]]
[[./figure/log_SFR_FUV_Ha.png]]
:end:


create the average SFR_0 from SFRHa SFRFUV with np.ma.average

#+begin_src python
# Calculate the mean of SFRHa and SFRFUV, ignoring masked values

SFR_0 = np.ma.mean(np.ma.array([dt["SFRHa"], dt["SFRFUV"]]), axis=0)
# Store the result in the table, applying the SFR unit
dt["SFR_0"] = MaskedColumn(SFR_0, unit = SFR_unit)

# Display statistical information about SFR_0, SFRFUV, and SFRHa
dt[["SFR_0", "SFRFUV", "SFRHa"]].info("stats")

#+end_src

#+RESULTS:
: <QTable length=1448>
:  name           mean                   std                    min                    max          n_bad
: ------ ---------------------- --------------------- ------------------------ -------------------- -----
:  SFR_0 0.0722542 solMass / yr 0.316258 solMass / yr 1.75917e-10 solMass / yr 4.38718 solMass / yr   190
: SFRFUV 0.0738724 solMass / yr 0.349917 solMass / yr 2.13796e-10 solMass / yr  5.7544 solMass / yr   321
:  SFRHa  0.116644 solMass / yr 0.408421 solMass / yr 1.38038e-10 solMass / yr  4.2658 solMass / yr   712


** Applying the cut SFR_0 >= 1e-3 solMass/yr

keep only the SFR_0 data were >1e-3

#+begin_src python
dc = dt.copy()
dc = dc[dc["SFR_0"].value >= 1e-3]

print(dc["SFR_0"].info())
#+end_src

#+RESULTS:
#+begin_example
[0;33mWARNING[0m: column logKLum has a unit but is kept as a MaskedColumn as an attempt to convert it to Quantity failed with:
UnitTypeError("MaskedQuantity instances require normal units, not <class 'astropy.units.function.logarithmic.DexUnit'> instances.") [astropy.table.table]
[0;33mWARNING[0m: column logM26 has a unit but is kept as a MaskedColumn as an attempt to convert it to Quantity failed with:
UnitTypeError("MaskedQuantity instances require normal units, not <class 'astropy.units.function.logarithmic.DexUnit'> instances.") [astropy.table.table]
[0;33mWARNING[0m: column logMHI has a unit but is kept as a MaskedColumn as an attempt to convert it to Quantity failed with:
UnitTypeError("MaskedQuantity instances require normal units, not <class 'astropy.units.function.logarithmic.DexUnit'> instances.") [astropy.table.table]
name = SFR_0
dtype = float64
unit = solMass / yr
class = MaskedQuantity
n_bad = 0
length = 607
None
#+end_example

#+begin_src python

dc[["SFR_0","SFRFUV", 'SFRHa']].info("stats")
#+end_src

#+RESULTS:
: <QTable length=607>
:  name           mean                  std                    min                    max          n_bad
: ------ --------------------- --------------------- ------------------------ -------------------- -----
:  SFR_0 0.149597 solMass / yr 0.442412 solMass / yr  0.00102329 solMass / yr 4.38718 solMass / yr     0
: SFRFUV 0.161775 solMass / yr 0.504243 solMass / yr 6.60693e-05 solMass / yr  5.7544 solMass / yr    93
:  SFRHa 0.172679 solMass / yr  0.48719 solMass / yr 2.04174e-05 solMass / yr  4.2658 solMass / yr   110



Histogram of SFR_0

#+begin_src python
#log of SFR_0
dc["logSFR_0"] =MaskedColumn(np.log10(dc["SFR_0"].value),unit = SFR_unit)
dc["logSFR_0"].info()
#+end_src

#+RESULTS:
: name = logSFR_0
: dtype = float64
: unit = solMass / yr
: class = MaskedQuantity
: n_bad = 0
: length = 607



#+begin_src python :results value file

hist(dc["logSFR_0"].value, bins = "freedman")

plt.title("Histogram of $SFR_0$")
plt.xlabel(r"$\log(SFR_0/[{}])$".format(dc["SFR_0"].unit.to_string("unicode")))
plt.ylabel("Number of Galaxies")
#save fig, plt close and print fig file name
fname = "figure/log_SFR_0_hist.png"
plt.savefig(fname)
plt.close()
fname
#+end_src

#+RESULTS:
[[file:figure/log_SFR_0_hist.png]]



** Theoretical Average SFR

To calculate the average Star Formation Rate $\overline{SFR}$ we can use the equation

$$
    \overline{SFR}=\frac{\zeta M_*}{t_{sf}}
$$

where Œ∂ is the mass-loss through stellar evolution and we assume that $\zeta\approx 1.3$ (see explanation in the paper`), M* is the stellar mass of each galaxy and we assume that is   $t_{sf}=12.5\ Gyr$

#+begin_src python

dc["av_SFR_theor"] = 1.3 * dc["StellarMass"] / t_sf.to(u.yr)
dc["av_SFR_theor"].info()
#+end_src

#+RESULTS:
: name = av_SFR_theor
: dtype = float64
: unit = solMass / yr
: description = Linear K_S_ band luminosity
: class = MaskedQuantity
: n_bad = 1
: length = 607

#+begin_src python

plt.scatter(y = dc["av_SFR_theor"],x = dc["SFR_0"], c = dc["color"].value)
#colobar
plt.colorbar()

plt.xscale("log")
plt.yscale("log")
plt.show()
#+end_src

#+RESULTS:


** Ratio av_SFR/SFR_0


Now we have to calculate the ratio $\frac{\overline{SFR}}{SFR_0}$

#+begin_src python
dc["SFR_ratio"] = dc["av_SFR_theor"] / dc["SFR_0"]

#log10 of ratio
dc["logSFR_ratio"] = np.log10(dc["SFR_ratio"])

dc[["SFR_ratio", "logSFR_ratio"]].info(["attributes","stats"])
#+end_src

#+RESULTS:
: /home/dp/.local/lib/python3.10/site-packages/astropy/utils/masked/core.py:879: RuntimeWarning: divide by zero encountered in log10
: <QTable length=607>
:     name      dtype          description             class         mean     std       min      max   n_bad
: ------------ ------- --------------------------- -------------- --------- -------- --------- ------- -----
:    SFR_ratio float64 Linear K_S_ band luminosity MaskedQuantity   5.77922  45.5965 0.0325391 1054.18     1
: logSFR_ratio float64 Linear K_S_ band luminosity MaskedQuantity 0.0646566 0.515905  -1.48759 3.02291     1

log10 of ratio

#+begin_src python
plt.scatter(y = dc["SFR_ratio"],x = dc["SFR_0"], c = dc["color"].value)
#colobar
plt.colorbar()

plt.xscale("log")
plt.yscale("log")
plt.show()
#+end_src

#+RESULTS:

Scatter color and ratio

#+begin_src python :results value drawer file
plt.scatter(y = dc["SFR_ratio"],x =dc["color"], c = np.log10(dc["mass_ratio"].value), cmap = "viridis" )
#title and labels with units in latex
plt.yscale("log")
plt.title(r"$\frac{\overline{SFR}}{SFR_0}$ - <FUV-B>")
plt.ylabel(r"$\frac{\overline{SFR}}{SFR_0}$")
plt.xlabel("<FUV-B>")
plt.colorbar(label = r"$M_g/M_*$")
#save in dir figure
plt.tight_layout()
plt.savefig("figure/ratio_vs_color.png")
plt.close()
#print file
"figure/ratio_vs_color.png"
#+end_src

#+RESULTS:
:results:
[[file:figure/ratio_vs_color.png]]
:end:


* The Delayed-\tau model

"The delayed-œÑ model describes the SFH of a galaxy assuming that the SFRs typically rise in the early phase of galaxy evolution and gradually decline to the present time (e.g. Reddy et al. 2012; Carnall et al. 2019). In fact, Speagle et al. (2014) showed in their figures 9 and 10 that the SFH of galaxies following the main sequence of star-forming galaxies can be accurately parametrized by the delayed-œÑ model of the form" [cite:@haslbauerCosmologicalStarFormation2023]


\begin{equation}
        \label{eq:SFR} SFR_{0,del}=\frac{A_{del}xe^{-x}}{\tau},\text{ where } x=\frac{tsf}{\tau}
\end{equation}

\noindent where

is the star formation time-scale, $tsf$ is the real time of star formation in a given galaxy and $Adel$ a normalization constant.

The average SFR is

\begin{equation}
        \label{eq:av_SFR-x} \overline{SFRdel}=\frac{Adel}{tsf}[1-(1+x)e^{-x}]
\end{equation}
and can also be defined by the present day stellar mass

\begin{equation}\label{eq:av_SFR M*}
        \overline{SFR}=\frac{\zeta M_*}{tsf}
\end{equation}

where
accommodates for mass-loss through stella evolution and This is a system of 2 equations and 3 variables

** Calculating A_{del}

*** Constant t_{sf}
The observed ages of galactic discs are $tsf‚âà 12$ Gyr[cite:@knoxSurveyCoolWhite1999a], so assuming an approximation of $tsf=12$ Gyr, the $\overline{SFR_{del}}$ can be calcuated, from the equation (\ref{eq:av_SFR M*}).


After that the equation of ratio

\begin{equation} \label{eq:ratio}                                        \frac{\overline{SFRdel}}{SFR0,del}=\frac{e^x-x-1}{x^2}
\end{equation}

can be solved numerically for x and using the equations (\Ref{eq:SFR}) and (\Ref{eq:av_SFR-x}) the $Adel$ and of each galaxy are found.

#+begin_src python
dc["SFR_0", "SFR_ratio", "StellarMass"].info()
#+end_src

#+RESULTS:
: <QTable length=607>
:     name     dtype      unit             description             class      n_bad
: ----------- ------- ------------ --------------------------- -------------- -----
:       SFR_0 float64 solMass / yr                             MaskedQuantity     0
:   SFR_ratio float64              Linear K_S_ band luminosity MaskedQuantity     1
: StellarMass float64      solMass Linear K_S_ band luminosity MaskedQuantity     1

#+begin_src python
ratio_array = np.array(dc["SFR_ratio"])
sfr_array = np.array(dc["SFR_0"])
mass_array = np.array(dc["StellarMass"])
tsf = t_sf/u.yr
x2 = np.empty(len(dc))

#+end_src

#+RESULTS:

*** Newton

#+begin_src python
for i in range(len(dc)-1):
    ratio = ratio_array[i]
    mass = mass_array[i]
    sfr = sfr_array[i]
    def f(x):
        return (-sfr + zeta*mass*x**2/(np.exp(x)-1-x)/tsf )  # only one real root

    def f_prime(x):
        return -zeta*mass*(x*(np.exp(x)*(x-2)+x+2)/(np.exp(x)-x-1)**2)/tsf

    sol = optimize.root_scalar(f, bracket=[0, 4], x0 = 3.4, fprime = f_prime, method="newton")
    x2[i] = sol.root

dc["x_n"] = x2
dc["A_n"] = dc["SFR_0"]*t_sf.to(u.yr)*np.exp(dc["x_n"])/(dc["x_n"]**2)

#+end_src

#+RESULTS:
: /home/dp/.local/lib/python3.10/site-packages/scipy/optimize/_root_scalar.py:315: RuntimeWarning: Derivative was zero.
: /home/dp/.local/lib/python3.10/site-packages/astropy/utils/masked/core.py:879: RuntimeWarning: divide by zero encountered in divide

#+begin_src python
print(dc["x_n", "A_n"].info("stats"))
#+end_src

#+RESULTS:
: /home/dp/.local/lib/python3.10/site-packages/astropy/utils/masked/core.py:879: RuntimeWarning: invalid value encountered in subtract
: <QTable length=607>
: name     mean        std             min             max
: ---- ----------- ----------- ------------------- -----------
:  x_n     1.66244     2.91609            -29.6974     11.9164
:  A_n inf solMass nan solMass 1.60997e-08 solMass inf solMass
: None

#+begin_src python :results value drawer

# Assuming you have already loaded your data into an Astropy table named 'dts'
# Replace 'x' with the name of the column you want to plot


# Create a histogram                                                      #
hist(dc["x_n"], bins = "freedman")  # Adjust the number of bins as needed #
plt.xlabel('X values')                                                    #
plt.ylabel('Frequency')                                                   #
plt.title('Histogram of Astropy Column "x"')                              #
plt.show()                                                                #


#+end_src

#+RESULTS:
:results:
None
:end:

*** fsolve

#+begin_src python
from scipy.optimize import fsolve
# Example loop
x = np.ma.empty(len(dc))
A = np.ma.empty(len(dc))
for i in range(len(dc)-1):

    ratio = ratio_array[i]
    mass = mass_array[i]
    sfr = sfr_array[i]
    def sfrx(z):
        x = z[0]
        A = z[1]

        f = np.zeros(2)
        f[0] = ratio - (np.exp(x) - x - 1) / x**2
        f[1] = sfr - A * x * tsf * np.exp(-x) / x
        return f

    # Solve the equation
    z = fsolve(sfrx, [3,1e+9])
    x[i] = z[0]
    A[i] = z[1]

    ## mask If sfr ratio or mass is nan
    if np.isnan(ratio) or np.isnan(mass):
        x[i] = np.nan
        A[i] = np.nan

dc["x_f"] = MaskedColumn(x, name = "x")
dc["A_f"] = MaskedColumn(A, name = "A", unit = u.solMass)
#+end_src

#+RESULTS:
: /tmp/babel-fZ8WA9/python-gIdtr8:20: RuntimeWarning: The iteration is not making good progress, as measured by the
:   improvement from the last five Jacobian evaluations.

#+begin_src python
print(dc["x_f","A_f"].info(["attributes" ,"stats"]))
#+end_src

#+RESULTS:
: <QTable length=607>
: name  dtype    unit      class             mean              std              min              max
: ---- ------- ------- -------------- ------------------ ---------------- ---------------- ---------------
:  x_f float64           MaskedColumn            1.63251          2.99038         -29.6974         11.9164
:  A_f float64 solMass MaskedQuantity 0.00717576 solMass 0.360915 solMass -1.49288 solMass 8.66436 solMass
: None

#+begin_src python :results value
np.mean(dc["av_SFR_theor"]*t_sf.to(u.yr))
#+end_src

#+RESULTS:
: 4892850694.595909 solMass

scatter of x2 and A

*** Compare the methods

**** For X

#+begin_src python
plt.scatter(dc["x_f"], dc["A_f"])

plt.xlabel('x')
plt.ylabel('$A_{del}$')
plt.yscale("log")
plt.title('scatter of x and A')
plt.show()
#+end_src

#+RESULTS:


#+begin_src python :results value file drawer

hist(dc["x_f"], bins = "freedman")                   #
hist(dc["x_n"], bins = "freedman", alpha = 0.6)      #
plt.xlabel('x')                                      #
plt.ylabel("Number of galaxies")                     #
plt.title('Hist of x solved with fsolve and Newton') #
#show the labels                                     #
plt.legend(["fsolve", "Newton"])                     #
                                                     #
plt.savefig("figure/x-hist.png")                     #
plt.close()                                          #
                                                     #
"figure/x-hist.png"                                  #

#+end_src

#+RESULTS:
:results:
[[file:figure/x-hist.png]]
:end:

#+begin_src python
fig = px.histogram(dc.to_pandas(), x = "x_n", hover_data = dc.to_pandas().columns)
fig = px.histogram(dc.to_pandas(), x = "x_f", hover_data = dc.to_pandas().columns)
fig.show()

#+end_src

#+RESULTS:

#+begin_src python
print(dc["x_f","x_n"].info(["attributes" ,"stats"]))
#+end_src

#+RESULTS:
: <QTable length=607>
: name  dtype     class       mean    std     min      max
: ---- ------- ------------ ------- ------- -------- -------
:  x_f float64 MaskedColumn 1.63251 2.99038 -29.6974 11.9164
:  x_n float64       Column 1.66244 2.91609 -29.6974 11.9164
: None


#+begin_src python :results value file drawer
plt.scatter(dc["x_f"], dc["x_n"])
plt.xlabel('$x_{fsolve}$')
plt.ylabel(r'$x_{Newton}$')
plt.title('scatter of $x_{Newton}$ and $x_{fsolve}$')
#savefig and print the file
plt.savefig("figure/x-scatter.png")
plt.close()

"figure/x-scatter.png"
#+end_src

#+RESULTS:
:results:
[[file:figure/x-scatter.png]]
:end:


Since they are both pretty much the same, we can assume that the more compact is better, ie fsolve.

**** They have the same max and min

Let's find the Galaxies (Name) with the min and max x_f and x_n

#+begin_src python :results output
print("MAX of x_n:", dc["Name"][np.argmax(dc["x_n"])])
print("MIN of x_n:", dc["Name"][np.argmin(dc["x_n"])])
print("MAX of x_f:", dc["Name"][np.argmax(dc["x_f"])])
print("MIN of x_f:", dc["Name"][np.argmin(dc["x_f"])])
#+end_src

#+RESULTS:
: MAX of x_n: Maffei1
: MIN of x_n: AGC124056
: MAX of x_f: Maffei1
: MIN of x_f: AGC124056

What are those galaxies?

#+begin_src python
print("MAX of SFR Ratio:", dc["Name"][np.argmax(dc["SFR_ratio"])])
print("MIN of SFR Ratio:", dc["Name"][np.argmin(dc["SFR_ratio"])])
#+end_src

#+RESULTS:
: MAX of SFR Ratio: Maffei1
: MIN of SFR Ratio: AGC124056

*** Sigma Clip for tau


#+begin_src python
print(dc["A_f","A_n"].info(["attributes" ,"stats"]))
#+end_src

#+RESULTS:
#+begin_example
/home/dp/.local/lib/python3.10/site-packages/astropy/utils/masked/core.py:879: RuntimeWarning:

invalid value encountered in subtract

<QTable length=607>
name  dtype    unit      class             mean              std                min               max
---- ------- ------- -------------- ------------------ ---------------- ------------------- ---------------
 A_f float64 solMass MaskedQuantity 0.00717576 solMass 0.360915 solMass    -1.49288 solMass 8.66436 solMass
 A_n float64 solMass MaskedQuantity        inf solMass      nan solMass 1.60997e-08 solMass     inf solMass
None
#+end_example



#+begin_src python :results value file
hist(dc["A_n"], bins = "blocks", density = False)
plt.xscale("log")
plt.xlabel('$A_{del}$'+f'[{dc["A_n"].unit:latex}]')

plt.xlim(np.min(dc["A_f"]))
plt.ylabel("Number of galaxies")
plt.title('Histogram of $A_{del}$')
#save
plt.savefig("figure/A-hist.png")
plt.close()

"figure/A-hist.png"
#+end_src

#+RESULTS:
[[file:figure/A-hist.png]]



** Calculating and \tau of the galaxies

#+begin_src python

dc['tau'] = t_sf/dc["x_n"]

print(dc["tau"].info(["attributes", "stats"]))
#+end_src

#+RESULTS:
#+begin_example
/home/dp/.local/lib/python3.10/site-packages/astropy/units/quantity.py:671: RuntimeWarning:

overflow encountered in divide

/home/dp/.local/lib/python3.10/site-packages/astropy/units/quantity.py:671: RuntimeWarning:

invalid value encountered in subtract

name = tau
dtype = float64
unit = Gyr
class = Quantity
mean = inf Gyr
std = nan Gyr
min = -1036.91 Gyr
max = inf Gyr
n_bad = 1
length = 607
None
#+end_example

#+begin_src python :results file value
hist(dc["tau"], bins = "scott")
plt.xscale("log")
plt.xlabel(r'$\tau$')
plt.ylabel("Number of galaxies")
plt.title(r'Histogram of $\tau$')
#save
plt.savefig("figure/tau-hist.png")
plt.close()

"figure/tau-hist.png"
#+end_src

#+RESULTS:
[[file:figure/tau-hist.png]]

**** Min and Max of A_{del}

#+begin_src python
print(dc["A_f"].min(), dc["A_f"].max())
#+end_src

#+RESULTS:
: -1.4928809068793116 solMass 8.664356382669745 solMass

#+begin_src python :results drawer

print(r"MAX of $A_{del}$:", dc["Name"][np.argmax(dc["A_f"])])
print(r"MIN of $A_{del}$:", dc["Name"][np.argmin(dc["A_f"])])
print(r"MAX of $A_{del}$:", dc["Name"][np.argmax(dc["A_n"])])
print(r"MIN of $A_{del}$:", dc["Name"][np.argmin(dc["A_n"])])
#+end_src

#+RESULTS:
:results:
MAX of $A_{del}$: NGC2787
MIN of $A_{del}$: DDO120
MAX of $A_{del}$: dw1343+58
MIN of $A_{del}$: AGC124056
:end:

#+begin_src python :results file value
plt.close("all")
colval = dc["StellarMass"]
colormap = np.log10(colval.data)
plt.scatter(dc["x_a"], dc["A_f"], c=colormap, cmap = "viridis")
plt.title('Scatter plot of A vs x')
plt.xlabel("x")
plt.ylabel(r'$A_{del}$ '+ f'[{dc["A_f"].unit:latex}]')
plt.yscale("log")

plt.colorbar(label = r"$\log(M_*/{})$".format(colval.unit.to_string(format="unicode") ))
plt.savefig("figure/tau-A.png")
plt.show()
plt.close()

"figure/tau-A.png"
#+end_src

#+RESULTS:
[[file:]]


#+begin_src python :results value file drawer

filename = "figure/tau-A"

plt.scatter(dc["tau"], dc["A_n"], c=np.log10(dc["StellarMass"]/dc["StellarMass"].unit), cmap = "viridis")
plt.title('Scatter plot of A vs x')
plt.xlabel(r'$\tau$ '+ f'[{dc["tau"].unit:latex}]')
plt.ylabel(r'$A_{del}$ '+ f'[{dc["A_f"].unit:latex}]')
plt.yscale("log")

plt.colorbar()

plt.savefig(filename+".png")
plt.show()
plt.close()

filename + ".png"
#+end_src

#+RESULTS:
:results:
[[file:figure/tau-A.png]]
:end:

*** TODO Add zoom and theoretical lines

#+begin_src python
tmp = dc.to_pandas()
fig = px.scatter(tmp, "tau", "A_f", hover_data = ["Name", "TType"], log_y = False)
fig.show()
#+end_src

#+RESULTS:

#+begin_src python :results value file

plt.close()
# Assuming dc is your QTable containing the data
colval = dc["StellarMass"]
colormap = np.log10(colval.data)
plt.scatter(dc["x_n"], dc["A_n"], c=colormap, cmap="viridis")
plt.title('Scatter plot of A vs x')
plt.xlabel("x")
plt.ylabel(r'$A_{del}$ '+ f'[{dc["A_f"].unit:latex}]')
plt.yscale("log")

plt.colorbar(label = r"$\log(M_*/{})$".format(colval.unit.to_string(format="unicode") ))

# Define the function to plot
def func(x, a):
    return 1 / (1 - (1 + x) * np.exp(-x)) * a

# Generate x values
x_values = np.linspace(dc["x_n"].min(), dc["x_n"].max(), 1000)

# Define the value of a
a_value = dc["av_SFR_theor"].mean()*t_sf.to(u.yr)  # Replace with your desired value of a

# Calculate y values using the function
y_values = func(x_values, a_value)

# Plot the function
plt.plot(x_values, y_values, label=r"$\overline{SFR} \cdot t_{sf}  \cdot \frac{1}{1-\left(1+x\right)e^{-x}}$")
plt.legend()

plt.savefig("figure/tau-A.png")
plt.show()
plt.close()
print(y_values.unit)
"figure/tau-A.png"

#+end_src

#+RESULTS:
[[file:figure/tau-A.png]]

*** IDEA Check to see if the almost inf points make any sense

** TODO The gas depletion timescale \tau_g

"The gas depletion timescale œÑg measures the time taken by a galaxy to exhaust its gas content Mg given the current SFR (Pflamm-Altenburg & Kroupa 2009). We employ two methods to determine œÑg. In the first method, we find

$$
\tau_g = \frac{M_g}{\dot{M_*}}
$$

where Mg is the neutral gas mass at the desired time and $\dot{M_*}$ is the SFR then."[cite:@nageshSimulationsStarformingMainsequence2023]

#+begin_src python

dc["tau_g"] = dc["M_g"]/dc["SFR_0"]
dc["tau_g"].info("stats")
#+end_src

#+RESULTS:
: name = tau_g
: mean = 1.65347e+10 yr
: std = 3.08891e+10 yr
: min = 2.10766e+08 yr
: max = 4.6116e+11 yr
: n_bad = 41
: length = 607

** TODO The theoretical SFR vs the observed


* PROJ The relations of the Masses
Since the aim of the paper is to find the SFR lets first understand and calculate the masses of the galaxies and see if we can find any relation with the SFR.

#+begin_src python

df = dc.to_pandas()
# Assuming df is your DataFrame
# Step 1: Identify non-numeric columns
non_numeric_columns = df.select_dtypes(exclude=['float', 'int']).columns

# Step 2: Drop non-numeric columns or handle them appropriately
df_numeric = df.drop(columns=non_numeric_columns)
# Step 3: Replace NaN values with zeros or other appropriate values

df_numeric = df_numeric.loc[:, ~df_numeric.columns.str.startswith('e_')]

df_numeric = df_numeric.loc[:, ~df_numeric.columns.str.startswith('Name')]
df_numeric = df_numeric.loc[:, ~df_numeric.columns.str.startswith('Coord')]
df_numeric = df_numeric.loc[:, ~df_numeric.columns.str.startswith('log')]
# Step 4: Calculate the correlation matrix
correlation_matrix = df_numeric.corr()

plt.close("all")
#+end_src

#+RESULTS:

#+begin_src python
# Plot heatmap using seaborn
sns.heatmap(correlation_matrix, annot=False, cmap='coolwarm', fmt=".2f", linewidths=0.5)
# Set x-axis tick labels
plt.xticks(ticks=np.arange(0.5, len(correlation_matrix.columns)), labels=correlation_matrix.columns, rotation=90)

# Set y-axis tick labels
plt.yticks(ticks=np.arange(0.5, len(correlation_matrix.index)), labels=correlation_matrix.index, rotation=0)
plt.title('Correlation Heatmap')
plt.savefig("figure/heatmap")
plt.show()
plt.close("all")

#+end_src

#+RESULTS:

#+begin_src python
clustermap = sns.clustermap(correlation_matrix, cmap='coolwarm', fmt=".2f", linewidths=0.5,
                             row_cluster=False, col_cluster=False)

ax = clustermap.ax_heatmap

# Set x-axis tick labels
ax.set_xticks(np.arange(0.5, len(correlation_matrix.columns)))
ax.set_xticklabels(correlation_matrix.columns, rotation=90)

# Set y-axis tick labels
ax.set_yticks(np.arange(0.5, len(correlation_matrix.index)))
ax.set_yticklabels(correlation_matrix.index, rotation=0)


plt.savefig("figure/clustermap")
plt.show()
plt.close("all")

#+end_src

#+RESULTS:

#+begin_src python
fig = px.imshow(correlation_matrix, text_auto = True, color_continuous_scale='RdBu_r')
fig.show()
fig.write_html("figure/correlation.html")
#+end_src

#+RESULTS:

Pairplot with StellarMass, MHI, SFR_0 and av_SFR, M26

#+begin_src python
#PairGrid with StellarMass, MHI, SFR_0 and av_SFR_theor, M26
#log scale axes

sns.pairplot(df, vars=["StellarMass", "MHI", "SFR_0", "av_SFR_theor", "M26"], kind="reg", diag_kind="kde")
plt.savefig("figure/pairplot")
plt.show()
plt.close("all")
print(df[["StellarMass", "MHI", "SFR_0", "av_SFR_theor", "M26", "M_g", "tau", "A_f"]].corr())
#+end_src

#+RESULTS:
:               StellarMass       MHI     SFR_0  av_SFR_theor       M26       M_g       tau       A_f
: StellarMass      1.000000  0.494516  0.575623      1.000000  0.829324  0.494516 -0.017759 -0.001169
: MHI              0.494516  1.000000  0.776005      0.494516  0.493378  1.000000 -0.026803 -0.012538
: SFR_0            0.575623  0.776005  1.000000      0.575623  0.517808  0.776005 -0.042936 -0.023519
: av_SFR_theor     1.000000  0.494516  0.575623      1.000000  0.829324  0.494516 -0.017759 -0.001169
: M26              0.829324  0.493378  0.517808      0.829324  1.000000  0.493378 -0.023729  0.005219
: M_g              0.494516  1.000000  0.776005      0.494516  0.493378  1.000000 -0.026803 -0.012538
: tau             -0.017759 -0.026803 -0.042936     -0.017759 -0.023729 -0.026803  1.000000 -0.001645
: A_f             -0.001169 -0.012538 -0.023519     -0.001169  0.005219 -0.012538 -0.001645  1.000000

#+begin_src python :exports none :results none
#define a new dataframe
df_log = pd.DataFrame()

temp = pd.DataFrame()
for i in ["StellarMass", "MHI", "SFR_0", "av_SFR_theor", "M26", "tau", "A_f", "M_g", "tau_g", "BarMass"]:
    temp [i] =df[i]
    temp[i].loc[temp[i] == 0] = np.nan
    df_log[i] = np.log(temp[i].dropna())

for i in ["TType", "Tdw1", "Tdw2"]:
    df_log[i] = df[i]
#+end_src

#+begin_src python
#PairGrid with StellarMass, MHI, SFR_0 and av_SFR_theor, M26
#log scale axes

sns.pairplot(df_log, vars=["StellarMass", "MHI", "SFR_0", "M26", "BarMass", "A_f"], kind="reg", diag_kind="kde")
plt.savefig("figure/pairplot")
plt.show()
plt.close("all")
print(df_log[["MHI", "SFR_0", "av_SFR_theor", "M26", "M_g", "tau", "A_f", "tau_g"]].corr())
#+end_src

#+RESULTS:
:                    MHI     SFR_0  av_SFR_theor       M26       M_g       tau       A_f     tau_g
: MHI           1.000000  0.861085      0.784292  0.850949  1.000000 -0.050178  0.137310 -0.040938
: SFR_0         0.861085  1.000000      0.855756  0.854753  0.861085 -0.027560  0.076759 -0.543286
: av_SFR_theor  0.784292  0.855756      1.000000  0.894117  0.784292 -0.369881  0.121378 -0.428340
: M26           0.850949  0.854753      0.894117  1.000000  0.850949 -0.227644  0.080755 -0.285532
: M_g           1.000000  0.861085      0.784292  0.850949  1.000000 -0.050178  0.137310 -0.040938
: tau          -0.050178 -0.027560     -0.369881 -0.227644 -0.050178  1.000000 -0.554354 -0.022487
: A_f           0.137310  0.076759      0.121378  0.080755  0.137310 -0.554354  1.000000  0.067690
: tau_g        -0.040938 -0.543286     -0.428340 -0.285532 -0.040938 -0.022487  0.067690  1.000000

#+begin_src python :results file value
#heatmap of masses and luminosities
sns.heatmap(df_log[["MHI", "SFR_0", "av_SFR_theor", "M26", "M_g", "BarMass","tau", "A_f", "tau_g"]].corr(), annot = True)
fname = "figure/heatmap_mass_sfr_a_t.png"
plt.savefig(fname)
plt.show()
plt.close()

fname
#+end_src

#+RESULTS:
[[file:figure/heatmap_mass_sfr_a_t.png]]

* TODO The relations of the Data

** Luminosities

Let's find some relations between the magnitudes
We will use the mags of table 3

#+begin_src python :results file
#find all the columns of df with mag_

mag_cols = [col for col in df.columns if "mag_" in col]

#drop the but the ones with l_mag
mag_cols = [col for col in mag_cols if "l_mag" not in col]
mag_cols = [col for col in mag_cols if "e_mag" not in col]

#create a new dataframe
df_mags = df[mag_cols]

#heatmap
filename = "figure/heatmap_mags.png"
sns.heatmap(df_mags.corr(), annot = True, fmt = ".3g")
plt.savefig(filename)
plt.show()
plt.close("all")

#print the file name
print(filename)
#+end_src

#+RESULTS:
[[file:figure/heatmap_mags.png]]

** TODO Luminosity and Masses

#+begin_src python

#+end_src

#+RESULTS:


** TODO Variations in Star Formation Rates across the different masses


* TODO Filling the Catalogue
