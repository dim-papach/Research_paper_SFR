#+title:Investigations of the galaxies of the LCV
#+author: Dimitrios Papachistopoulos
#+PROPERTY: header-args :lang python :eval python :exports results :tangle final.py :results value drawer :session main


#+OPTIONS: toc:nil
#+LaTeX_CLASS_OPTIONS: [a4paper,twocolumn]
#+LaTeX_HEADER: \usepackage{breakcites}
#+LaTeX_HEADER: \usepackage{paralist}
#+LaTeX_HEADER: \usepackage{amsmath}
#+LaTeX_HEADER: \usepackage{biblatex}
#+LaTeX_HEADER: \usepackage{hyperref}
#+LaTeX_HEADER: \usepackage{graphicx}
#+LaTeX_HEADER: \usepackage{caption}
#+LaTeX_HEADER: \usepackage{booktabs}
#+LaTeX_HEADER: \usepackage[T1]{fontenc}
#+LaTeX_HEADER: \usepackage{tgbonum}
#+LaTeX_HEADER: \let\itemize\compactitem
#+LaTeX_HEADER: \let\description\compactdesc
#+LaTeX_HEADER: \let\enumerate\compactenum

#+bibliography:./bibl/bibliography/bibliography.bib

#+begin_src python :results none
import numpy as np
import pandas as pd
from scipy.optimize import fsolve
import matplotlib.pyplot as plt
import seaborn as sns
import statsmodels.api as sm
import statsmodels.formula.api as smf
from tabulate import tabulate
import uncertainties as unc



pd.set_option('display.float_format', lambda x: '%.2E' % x)
######Print images with caption
def caption(fname,caption,name = None):
    if name == None:
        name = caption
    return "#+caption:{} \n#+name: fig:{} \n#+label: fig:{} \n[[./{}.png]]".format(caption,name,name,fname)

def simple_regplot(data ,
    X, Y, cap = None, name = None, n_std=2, n_pts=100, ax=None, scatter_kws=None, line_kws=None, ci_kws=None):
    df=data
    x=df[X]
    y=df[Y]
    """ Draw a regression line with error interval. """
    ax = plt.gca() if ax is None else ax

    # calculate best-fit line and interval
    x_fit = sm.add_constant(x)
    fit_results = sm.OLS(y, x_fit,missing='drop').fit()

    xconst=f'{fit_results.params[1]:.3f}'
    const=f'{fit_results.params[0]:.3f}'
    eval_x = sm.add_constant(np.linspace(np.min(x), np.max(x), n_pts))
    pred = fit_results.get_prediction(eval_x)

    # draw the fit line and error interval
    ci_kws = {} if ci_kws is None else ci_kws
    ax.fill_between(
        eval_x[:, 1],
        pred.predicted_mean - n_std * pred.se_mean,
        pred.predicted_mean + n_std * pred.se_mean,
        facecolor ='red',
        alpha=0.5,
        ,**ci_kws,
    )
    line_kws = {} if line_kws is None else line_kws
    h = ax.plot(eval_x[:, 1], pred.predicted_mean, **line_kws,color='red',linestyle='dashed',label= Y+"="+xconst+X+"+"+const)

    # draw the scatterplot
    scatter_kws = {} if scatter_kws is None else scatter_kws
    ax.scatter(x, y, **scatter_kws,label="Data")

    ax.set_title(Y+ "=f("+X+ ")")
    ax.grid()
    ax.set_xlabel(X)
    ax.set_ylabel(Y)
    ax.legend(loc = "best")
    if scatter_kws == {}:
        lab = X+"-"+Y
        fname = "figs/"+lab
        plt.savefig(fname)
        plt.close()
    else:
        col = scatter_kws["c"].name
        PCM=ax.get_children()[2] #get the mappable, the 1st and the 2nd are the x and y axes
        plt.colorbar(PCM, ax=ax).set_label(col)
        lab = X+"-"+Y+"-color_"+col
        fname = "figs/"+lab
        plt.savefig(fname)
        plt.close()

    if name == None:
        name = cap

    Cap = "#+caption:{} \n#+name: fig:{} \n#+label: fig:{} \n[[./{}.png]]".format(cap,name,name,fname)
    return fit_results, Cap , lab

# Calculate the bin width using the Freedman-Diaconis rule
def fd_bins(x):
    iqr = df[x].quantile(0.75) - df[x].quantile(0.25)
    bin_width = 2 * iqr / df[x].count()**(1/3)

    # Calculate the number of bins using the bin width
    return int((df[x].max() - df[x].min()) / bin_width)
#
## Format the table as a string using the tabulate library
def no_col_str(df,string):
    return df.drop(df.filter(regex=string).columns, axis=1)
#######


#### PRINTING THE OLS PARAMETERS AS LATEX
def inline_ols(y,x,ols):
        return "${} = ({:.ueSL})\cdot {} + ({:.ueSL})$".format(y, unc.ufloat(ols[0].params[1], ols[0].bse[1]), x, unc.ufloat(ols[0].params[0], ols[0].bse[0]))

def inline_r2(ols):
        return r"$R^2 = {}\%$".format(round(ols[0].rsquared*100))

def eq_ols(y,x,ols):
    return (r"\begin{"+"equation"+"}\label{eq:"+"{}".format(ols[2])+"}\n"+
            r"\begin{"+"align"+"}\n"+
            "& {} = ({:.ueSL})\cdot {} + ({:.ueSL}) \\\ \n".format(y, unc.ufloat(ols[0].params[1], ols[0].bse[1]), x, unc.ufloat(ols[0].params[0], ols[0].bse[0]))+
            r"& \textrm"+"{"+"with correlation "+"}"+" R^2={}\%\n".format(round(ols[0].rsquared*100))+
            r"\end{"+"align"+"}\n"+
            "\end{"+"equation"+"}\n")
#+end_src


#+begin_src python :results none

flag=pd.read_csv("Karachentsev_list_flags.csv")
colorcol=flag[["Name","Kmag"]].copy()

colorcol=colorcol[colorcol["Kmag"].astype(str).str.contains(">|<|\*")==False]

colorcol["Kmag"] = colorcol["Kmag"].astype('float')

data = pd.read_csv("Karachentsev_list.csv")
data["TType"] = data["TType"].astype('category')
data["Tdw1"] = data["Tdw1"].astype('category')
data["Tdw2"] = data["Tdw2"].astype('category')

df = data.copy()
df = pd.merge(colorcol[["Name", "Kmag"]], df, on = "Name", how = 'right')
df['SFR_Ha']=10**df['log_SFR_Ha']

df['SFR_FUV']=10**df['log_SFR_FUV']

df['K']=10**df['logKLum']

df['MHI']=10**df['logMHI']

df["color"] = df["Bmag"] - df['Kmag']
#+end_src


* The Galaxies in the Local Cosmological Volume (LCV)

The Catalogue of Neigbouring Galaxies (Karachentsev, Igor D. and Makarov  et al. 2013[cite:@karachentsevUPDATEDNEARBYGALAXY2013]) and its updated version from the "Catalog & Atlas of the LV galaxies" databas[cite:@CatalogLVGalaxies]  are used to extract the K-band luminosities, the types of the galaxie[fn:1]s, the mass within the Holmberg radius (M26), the Hydrogen masses of the galaxies ($M_{HI}$) and the SFRs based on integrated  H and far-ultraviolet (FUV) measurments for galaxies within a distance of
$\approx 11$ Mpc. The SFR and MHI values contain limit flags, which we exclude from our present analysis. This gives a sample of src_python[]{data.Name.count()} {{{results(793)}}} galaxies from src_python[]{flag.Name.count()} {{{results(1248)}}}. From the remaing galaxies we have

#+begin_src python
no_col_str(df,'log').count().to_latex(position = "hc")
#+end_src

#+RESULTS:
:results:
\begin{table}[hc]
\centering
\begin{tabular}{lr}
\toprule
{} &    0 \\
\midrule
Name    &  793 \\
Kmag    &  321 \\
FUVmag  &  687 \\
TType   &  793 \\
Tdw1    &  580 \\
Tdw2    &  568 \\
Bmag    &  790 \\
SFR\_Ha  &  566 \\
SFR\_FUV &  688 \\
K       &  789 \\
MHI     &  643 \\
color   &  321 \\
\bottomrule
\end{tabular}
\end{table}
:end:

+-------------+-------------------+
|Measurment   |Number of Galaxies |
+-------------+-------------------+


The K-band values are converted to the total Stellar Masses of each galaxy according to the mass-to-light ratio of 0.6 (\cite{lelliSPARCMASSMODELS2016}), and the $M_{HI}$ can be converted to the total mass of the gas of the galaxy using the equation $M_g=1.33\,M_{HI}$

The total SFR of each galaxy can be calcuated by

$$
    SFR_o=\frac{SFR_{FUV}+SFR_{Ha}}{2}
$$

if both $SFR_{H\alpha},SFR_{FUV}$ measurments are available. If only one only one of them is given, then the SFR is equal to the given SFR value

$$
    SFR_o=SFR_i,\ \text{if } SFR_j=0,i\neq j,\ i,j=FUV, H_a
$$

#+begin_src python :results none

##Average SFR
df['SFR_0']=df[ ['SFR_Ha','SFR_FUV']].mean(axis=1, skipna=True)
df['log_SFR_0']= np.log10(df['SFR_0'])
##Clipping
df=df[(df.SFR_0>=10**(-3))]

#Masses
df['StellarMass']=0.6*df['K']
df["logStellarMass"]=np.log10(df['StellarMass'])

df["Mg"]=1.33*df["MHI"]
df["logMg"]=np.log10(df["Mg"])

df["Mt"]=df["Mg"]+df["StellarMass"]
df['logMt']=np.log10(df['Mt'])

df["Mass_ratio"]=df["StellarMass"]/df["Mg"]
df["log_Mass_ratio"]=np.log10(df["Mass_ratio"])

df["logcolor"] = np.log10(df["color"])
#+end_src

The condition $SFR_o\geq 10^{-3}M_\odot yr^{-1}$ leaves src_python[]{df.Name.count()} {{{results(579)}}}
galaxies. This condition is applied due to the reasons given in the P. Kroupa,M. Haslbauer, I. Banik, S. T. Nagesh and J. Pflamm-Altenburg et al. 2020 \cite{kroupaConstraintsStarFormation2020}

* Types of galaxies

Using the dataset of 1248 galaxies, do before using the condition and removing the galaxies with the flags, the below histograms can be plotted.

Most of the galaxies in the LCV are Higly Irregular galaxies followed by lenticular galaxies

Out of the 1248 galaxies the 1022 are dwarf galaxies


Most dwarf galaxies have low brightness and are irregulars followed by Dwarf spheroidal.

#+begin_src python :results none

typ=pd.read_csv("Karachentsev_list_flags.csv")
typ["TType"]=typ["TType"].astype('category')
typ["Tdw1"]=typ["Tdw1"].astype('category')
typ["Tdw2"]=typ["Tdw2"].astype('category')
print(typ.count())
typ['TType'].value_counts(sort=False).plot(kind='bar',logy=True,grid = 'True')
plt.xlabel("Morphology")
plt.ylabel("Number of Galaxies")
plt.savefig("figs/hist-Type")
plt.close()
#+end_src
#+caption: The classification by de Vaucouleurs et al. (1991) is used for the morphology of the galaxies
#+name: Types of galaxies
[[./figs/hist-Type.png]]

#+begin_src python :results none
typ['Tdw1'].value_counts(sort=False).plot(kind='bar', logy=True,grid = 'True')
plt.xlabel("Dwarf galaxy morphology")
plt.ylabel("Number of Galaxies")
plt.savefig("figs/hist-Tdw1")
plt.close()

#+end_src
#+caption: Dwarf galaxy morphology
#+name: Types of dwarf galaxies
[[./figs/hist-Tdw1.png]]

#+begin_src python  :results none
typ['Tdw2'].value_counts(sort=False).plot(kind='bar', logy=True,grid = 'True')
plt.xlabel("Dwarf galaxy surface brightness morphology")
plt.ylabel("Number of Galaxies")
plt.savefig("figs/hist-Tdw2")
plt.close()
#+end_src
#+caption: Dwarf galaxy surface brightness morphology, where: H = high; N = normal; L = low; X = extremely low.
#+name: Types of dwarf galaxies brightness
[[./figs/hist-Tdw2.png]]


* Delayed-$\tau$ model

According to P. Kroupa et al. 2020[cite:@kroupaConstraintsStarFormation2020] current star formation rates of galaxies can be described by the 'delayed-$\tau$' mode as


\begin{equation} \label{eq:SFR}
SFR_{0,del}=\frac{A_{del}xe^{-x}}{\tau},\text{ where } x=\frac{t_{sf}}{\tau}
\end{equation}


where $\tau$ is the star formation time-scale,  $t_{sf}$ is the real time of star formation in a given galaxy and $A_{del}$ a normalization constant.

The average SFR is

\begin{equation}\label{eq:av_SFR-x}
\overline{SFR_{del}}=\frac{A_{del}}{t_{sf}}[1-(1+x)e^{-x}]
\end{equation}
and can also be defined by the present day stellar mass

\begin{equation}\label{eq:av_SFR M*}
    \overline{SFR}=\frac{\zeta M_*}{t_{sf}}
\end{equation}
where $\zeta$ accommodates for mass-loss through stella evolution and $\zeta\approx 1.3$

This is a system of 2 equations and 3 variables, since A_{del} has never been calculated

** Constant $t_{sf}$
The observed ages of galactic discs are $t_{sf}\approx 12$ Gyr[cite:@knoxSurveyCoolWhite1999], so assuming an approximation of $t_{sf}=12.5$ Gyr, the $\overline{SFR_{del}}$ can be calcuated, from the equation (\ref{eq:av_SFR M*}).

#+begin_src python :results none

###Constant tsf
dts=df.copy()
tsf=12.5*10**9
zeta=1.3

dts['av_SFR']=dts['StellarMass']*1.3/(12.5*10**9)
dts['log_av_SFR']=np.log10(dts['av_SFR'])

dts['ratio']=dts['av_SFR']/dts['SFR_0']
dts['log_ratio']=np.log10(dts['ratio'])

#+end_src

After that the equation of ratio



\begin{equation} \label{eq:ratio}
    \frac{\overline{SFR_{del}}}{SFR_{0,del}}=\frac{e^x-x-1}{x^2}
\end{equation}

can be solved numerically for $x$ and using the equations (\Ref{eq:SFR}) and (\Ref{eq:av_SFR-x}) the $A_{del}$ and $\tau$ of each galaxy are found.

#+begin_src python :results none
for i in dts.index:
    def sfrx(z):
        x = z

        ratio=dts.loc[i]['ratio']

        #f=ratio-(np.exp(x)-np.abs(x)-1)/x**2
        f=ratio-(np.exp(x)-np.exp(np.log(x))-1)/x**2
        return f

    #for i in dts.index:
    z = fsolve(sfrx,3.0)
    dts.at[i,'x_tsf']=(z)

#+end_src

#+begin_src python
dts['tau']=tsf/dts['x_tsf']
dts["log_tau"]=np.log10(dts["tau"])

dts["A_tsf"]=dts["av_SFR"]*tsf/(1-(1+dts["x_tsf"])*np.exp(-dts['x_tsf']))

dts[["A_tsf","tau","x_tsf"]].describe(include='all').to_latex(position = "hc")

#+end_src

#+RESULTS:
:results:
\begin{table}[hc]
\centering
\begin{tabular}{lrrr}
\toprule
{} &    A\_tsf &      tau &    x\_tsf \\
\midrule
count & 5.78E+02 & 5.79E+02 & 5.79E+02 \\
mean  & 2.25E+12 & 1.09E+11 & 1.85E+00 \\
std   & 3.94E+13 & 1.04E+12 & 1.48E+00 \\
min   & 2.48E+07 & 1.93E+09 & 5.59E-04 \\
25\%   & 1.41E+08 & 4.18E+09 & 5.65E-01 \\
50\%   & 6.84E+08 & 7.79E+09 & 1.60E+00 \\
75\%   & 5.70E+09 & 2.21E+10 & 2.99E+00 \\
max   & 9.10E+14 & 2.24E+13 & 6.47E+00 \\
\bottomrule
\end{tabular}
\end{table}
:end:

#+begin_src python 
fname = "figs/x-A_tsf"
dts.plot(kind='scatter', x='x_tsf', y='A_tsf',c= "logMt")
plt.xscale('log')
plt.yscale('log')
plt.savefig(fname)
plt.close()
caption(fname,"$A_{del} = f(x)$ for constant t_{sf}")
#+end_src

#+RESULTS:
:results:
#+caption:$A_{del} = f(x)$ for constant t_{sf}
#+name: fig:$A_{del} = f(x)$ for constant t_{sf}
#+label: fig:$A_{del} = f(x)$ for constant t_{sf}
[[./figs/x-A_tsf.png]]
:end:

#+begin_src python  :results file
fname = "figs/T-A_tsf"
dts.plot(kind='scatter', x='tau', y="A_tsf", c= "logMt")
plt.xscale('log')
plt.yscale('log')
plt.savefig(fname)
plt.close()
fname+'.png'
#+end_src

#+RESULTS:
:results:
[[file:figs/T-A_tsf.png]]
:end:


** Constant $\tau$

#+begin_src python :results none

###Constant tau
dtau=df.copy()
tau=3.5*10**9
zeta=1.3

dtau["z"]=zeta*dtau["StellarMass"]/tau
#+end_src

Assuming for an constant $\tau=3.5$ Gyr, we cannot use the same $\overline{SFR}$ since it depends on $t_{sf}$. Using the equations~(\Ref{eq:av_SFR M*}) and (\Ref{eq:ratio})

$$
    \frac{\overline{SFR_{del}}}{SFR_{0,del}}=\frac{e^x-x-1}{x^2}\Leftrightarrow \frac{e^x-x-1}{x}=\frac{\zeta M_*}{SFR\cdot\tau}
$$

using this equation $x$ and $A_{del}$ can be calcuated numerically.

#+begin_src python :results none
for i in df.index:
    def sfrx(z):
        x = z

        cons=dtau.loc[i]['z']
        SFR=dtau.loc[i]['SFR_0']


        #f=ratio-(np.exp(x)-np.abs(x)-1)/x**2
        f=cons/SFR-(np.exp(x)-np.exp(np.log(x))-1)/x
        return f

    #for i in df.index:
    z = fsolve(sfrx,3.0)
    dtau.at[i,'x_tau']=(z)
#+end_src

#+begin_src python :results none
dtau["tsf"]=dtau['x_tau']*tau
dtau["log_tsf"]=np.log10(dtau.tsf)
dtau["av_SFR"]=dtau.z/dtau.x_tau
dtau['ratio']=dtau.av_SFR/dtau.SFR_0
dtau['A_tau']=tau*dtau['SFR_0']*np.exp(dtau.x_tau)/dtau.x_tau
dtau=dtau.drop(["z"],axis=1)
#+end_src

#+begin_src python
dtau[["A_tau","x_tau","tsf"]].describe(include='all').to_latex(position = "hc")
#+end_src

#+RESULTS:
:results:
\begin{table}[hc]
\centering
\begin{tabular}{lrrr}
\toprule
{} &    A\_tau &    x\_tau &      tsf \\
\midrule
count & 5.79E+02 & 5.79E+02 & 5.79E+02 \\
mean  & 4.59E+09 & 2.54E+00 & 8.89E+09 \\
std   & 1.50E+10 & 9.57E-01 & 3.35E+09 \\
min   & 9.87E+06 & 4.07E-01 & 1.42E+09 \\
25\%   & 6.50E+07 & 1.87E+00 & 6.55E+09 \\
50\%   & 2.37E+08 & 2.44E+00 & 8.54E+09 \\
75\%   & 1.12E+09 & 3.08E+00 & 1.08E+10 \\
max   & 1.06E+11 & 5.77E+00 & 2.02E+10 \\
\bottomrule
\end{tabular}
\end{table}
:end:

#+begin_src python  
fname = "figs/x-A_tau"
dtau.plot(kind='scatter', x='x_tau', y='A_tau',c= "logMt")
plt.xscale('log')
plt.yscale('log')
plt.savefig(fname)
plt.close()

caption(fname,r"$A_{del} = f(x)$ for constant $\tau$")
#+end_src

#+RESULTS:
:results:
#+caption:$A_{del} = f(x)$ for constant $\tau$
#+name: fig:$A_{del} = f(x)$ for constant $\tau$
#+label: fig:$A_{del} = f(x)$ for constant $\tau$
[[./figs/x-A_tau.png]]
:end:


#+begin_src python  :results file
fname = "figs/T-A_tau.png"
dtau.plot(kind='scatter', x='tsf', y='A_tau',c= "logMt")
plt.xscale('log')
plt.yscale('log')
plt.savefig(fname)
plt.close()

fname
#+end_src

#+RESULTS:
:results:
[[file:figs/T-A_tau.png]]
:end:

** Comparing the two results

#+begin_src python :results none
dp=pd.merge(dtau[["Name","A_tau", "x_tau", "tsf"]], dts, on = 'Name')
dp["log_x_tau"]=np.log10(dp["x_tau"])
dp["log_x_tsf"]=np.log10(dp["x_tsf"])
dp["log_tau"]=np.log10(dp["tau"])
dp["log_tsf"]=np.log10(dp["tsf"])
#+end_src

*** Comparing the $x$'s


Comparing the two different results for x, we see that the $x|_\tau$ has a lower $\sigma$

#+begin_src python

dp[["x_tau","x_tsf"]].describe(include = 'all').to_latex(position = "hc")

#+end_src

#+RESULTS:
:results:
\begin{table}[hc]
\centering
\begin{tabular}{lrr}
\toprule
{} &    x\_tau &    x\_tsf \\
\midrule
count & 5.79E+02 & 5.79E+02 \\
mean  & 2.54E+00 & 1.85E+00 \\
std   & 9.57E-01 & 1.48E+00 \\
min   & 4.07E-01 & 5.59E-04 \\
25\%   & 1.87E+00 & 5.65E-01 \\
50\%   & 2.44E+00 & 1.60E+00 \\
75\%   & 3.08E+00 & 2.99E+00 \\
max   & 5.77E+00 & 6.47E+00 \\
\bottomrule
\end{tabular}
\end{table}
:end:

#+begin_src python

fname="figs/Comparing_the_x_Mt"

plt.scatter(data = dtau, y = "x_tau", x = "Mt", label=r"$\tau$=3.5 Gyr")
plt.scatter(data = dts, y = "x_tsf", x = "Mt",alpha=0.5,label="$t_{sf}$=12.5 Gyr")

plt.xscale('log')
plt.yscale('log')
plt.ylabel('x')
plt.xlabel('Mt')
plt.legend(loc='upper right')
plt.grid()
plt.savefig(fname)
plt.close()
caption(fname,"Comparing the two x's, According to their total masses")
#+end_src

#+RESULTS:
:results:
#+caption:Comparing the two x's, According to their total masses
#+name: fig:Comparing the two x's, According to their total masses
#+label: fig:Comparing the two x's, According to their total masses
[[./figs/Comparing_the_x_Mt.png]]
:end:
#+begin_src python

fname="figs/x_tau-Mt-color"

dtau.plot.scatter(x = "Mt",y = "x_tau", c = "logcolor")
plt.xscale('log')
plt.yscale('log')
plt.grid()
plt.savefig(fname)
plt.close()
caption(fname,r"$x|_\tau=f(M_t)$, with their color index")
#+end_src

#+RESULTS:
:results:
#+caption:$x|_\tau=f(M_t)$, with their color index
#+name: fig:$x|_\tau=f(M_t)$, with their color index
#+label: fig:$x|_\tau=f(M_t)$, with their color index
[[./figs/x_tau-Mt-color.png]]
:end:

#+begin_src python :results none
x_comp=simple_regplot(dp,'x_tsf','x_tau',cap = "Comparing the two x")
x_comp_Mt=simple_regplot(dp,'x_tsf','x_tau',scatter_kws={"c":dp["logMt"]},cap = "Comparing the two x, according to their total mass")
x_comp_tt=simple_regplot(dp,'x_tsf','x_tau',scatter_kws={"c":dp["TType"]},cap = "Comparing the two x, according to their type")
x_comp_col=simple_regplot(dp,'x_tsf','x_tau',scatter_kws={"c":dp["logcolor"]},cap = "Comparing the two x, according to their color index")
#+end_src

#+begin_src python
x_comp_Mt[1]
#+end_src

#+RESULTS:
:results:
#+caption:Comparing the two x, according to their total mass
#+name: fig:Comparing the two x, according to their total mass
#+label: fig:Comparing the two x, according to their total mass
[[./figs/x_tsf-x_tau-color_logMt.png]]
:end:

#+begin_src python
x_comp_tt[1]
#+end_src

#+RESULTS:
:results:
#+caption:Comparing the two x, according to their type
#+name: fig:Comparing the two x, according to their type
#+label: fig:Comparing the two x, according to their type
[[./figs/x_tsf-x_tau-color_TType.png]]
:end:

#+begin_src python
x_comp_col[1]
#+end_src

#+RESULTS:
:results:
#+caption:Comparing the two x, according to their color index
#+name: fig:Comparing the two x, according to their color index
#+label: fig:Comparing the two x, according to their color index
[[./figs/x_tsf-x_tau-color_logcolor.png]]
:end:

The two results are interrelated through the equation:
#+begin_src python
eq_ols(r"x|_\tau", "x|_{tsf}" , x_comp)
#+end_src

#+RESULTS:
:results:
\begin{equation}\label{eq:x_tsf-x_tau}
\begin{align}
& x|_\tau = (6.30(6) \times 10^{-1})\cdot x|_{tsf} + (1.374(15) \times 10^{0}) \\
& \textrm{with correlation } R^2=94\%
\end{align}
\end{equation}
:end:

and from the plots the following conclusions can be drawn:

1. The galaxies with a higher total mass deviate less from the linear fit and are older.
1. The younger galaxies are mainly later types of galaxies
1. For lower x's, the galaxies have a lower color index which indicates that they are younger. So the values are inline with the experimental values.

*** Comparing the normalization constants

#+begin_src  python 
#Comparing the 2 results
fname="figs/Comparing_the_A_x"
plt.scatter(data = dtau, x = "x_tau", y = "A_tau", label=r"$\tau$=3.5 Gyr")
plt.scatter(data = dts, x = "x_tsf", y = "A_tsf",alpha=0.5,label="$t_{sf}$=12.5 Gyr")
plt.xscale('log')
plt.yscale('log')
plt.xlabel('x')
plt.ylabel('A_del')
plt.legend(loc='upper right')
plt.grid()
plt.savefig(fname)
plt.close()
caption(fname,"Comparing the two A_{del}")
#+end_src

#+RESULTS:
:results:
#+caption:Comparing the two A_{del}
#+name: fig:Comparing the two A_{del}
#+label: fig:Comparing the two A_{del}
[[./figs/Comparing_the_A_x.png]]
:end:


#+begin_src python
fname = "figs/A_tau-A_tsf_colo_X"
dp.plot.scatter(x = "A_tsf",
                y = "A_tau",
                c = "x_tsf", grid = True)
plt.xscale('log')
plt.yscale('log')
plt.savefig(fname)
plt.close()
caption(fname, "Comparison of the 2 A_{del}s according to their $x$")

#+end_src

#+RESULTS:
:results:
#+caption:Comparison of the 2 A_{del}s according to their $x$
#+name: fig:Comparison of the 2 A_{del}s according to their $x$
#+label: fig:Comparison of the 2 A_{del}s according to their $x$
[[./figs/A_tau-A_tsf_colo_X.png]]
:end:
#+begin_src python
fname = "figs/A_tau-A_tsf_Mt"
dp.plot.scatter(x = "A_tsf",
                y = "A_tau",
                c = "logMt", grid = True)
plt.xscale('log')
plt.yscale('log')
plt.savefig(fname)
plt.close()
caption(fname, "Comparison of the 2 A_{del}s according to their total masses")

#+end_src

#+RESULTS:
:results:
#+caption:Comparison of the 2 A_{del}s according to their total masses
#+name: fig:Comparison of the 2 A_{del}s according to their total masses
#+label: fig:Comparison of the 2 A_{del}s according to their total masses
[[./figs/A_tau-A_tsf_Mt.png]]
:end:

For high $x$ and high masses the two A_{del}s have a high correlation. Specifically:
1. For high $x$ the $A_{del}|_{\tau}-A_{del}|_{t_{sf}}$ plot follows a $y=x$ trend, which means that for older stars and stars with a low star formation timescale $\tau$, the normalization constant is the same despite the method used to calculate it.
1. The same is true for more massive galaxies, since they deviate less from the $y=x$ line


* The gas depletion timescale $\tau_g$

The gas depletion timescale $\tau_g$ measures the time taken by a galaxy to exhaust its gas content Mg given the current SFR[cite:@nageshSimulationsStarformingMainsequence2023; @pflamm-altenburgFundamentalGasDepletion2009].
$$
\tau_g=\frac{M_g}{\dot{M_*}}=\frac{M_g}{SFR}
$$

#+begin_src python :results none
cols_to_use = dp.columns.difference(df.columns)
dtg = pd.merge(df, dp[cols_to_use], left_index=True, right_index=True, how='outer')

dtg["tau_g"]=df["Mg"]/df["SFR_0"]
dtg["log_tau_g"]=np.log10(dtg["tau_g"])

#+end_src

#+begin_src python
fname = "figs/tau_g-Mg-color_StellarMass"
dtg.plot(kind="scatter",x="Mg",y="tau_g", c = 'logStellarMass')
plt.xscale('log')
plt.yscale('log')
plt.grid()
plt.savefig(fname)
plt.close()
caption(fname, r"$\tau_g = f(M_g)$, with the Stellar Mass of the galaxies")

#+end_src

#+RESULTS:
:results:
#+caption:$\tau_g = f(M_g)$, with the Stellar Mass of the galaxies
#+name: fig:$\tau_g = f(M_g)$, with the Stellar Mass of the galaxies
#+label: fig:$\tau_g = f(M_g)$, with the Stellar Mass of the galaxies
[[./figs/tau_g-Mg-color_StellarMass.png]]
:end:

#+begin_src python

taug_StellarMass=simple_regplot(dtg,"logStellarMass","log_tau_g",scatter_kws={"c":dtg["log_SFR_0"]}, cap = r"Correlation of the $\tau_g$ with the SFR and the Stellar mass")
taug_StellarMass[1]
#+end_src

#+RESULTS:
:results:
#+caption:Correlation of the $\tau_g$ with the SFR and the Stellar mass
#+name: fig:Correlation of the $\tau_g$ with the SFR and the Stellar mass
#+label: fig:Correlation of the $\tau_g$ with the SFR and the Stellar mass
[[./figs/logStellarMass-log_tau_g-color_log_SFR_0.png]]
:end:

Even though the logarithmic correlation is low (src_python{inline_r2(taug_StellarMass)} {{{results($R^2 = 21\%$)}}}), there seems to be a pattern wherein the decrease of $\tau_g$ corresponds to an increase in the values of the Stellar Mass and the current star formation $SFR_0$.

#+begin_src python

taug_Mt=simple_regplot(dtg,"logMt","log_tau_g",scatter_kws={"c":dtg["logMg"]}, cap = r"Correlation of the $\tau_g$ with the total mass and the mass of the gas")
taug_Mt[1]
#+end_src

#+RESULTS:
:results:
#+caption:Correlation of the $\tau_g$ with the total mass and the mass of the gas
#+name: fig:Correlation of the $\tau_g$ with the total mass and the mass of the gas
#+label: fig:Correlation of the $\tau_g$ with the total mass and the mass of the gas
[[./figs/logMt-log_tau_g-color_logMg.png]]
:end:


Again it can be observed that as the $\tau_g$ decreases, the corresponding values of $M_t$ and $M_g$ increase, but the logarithmic correlation is again low (src_python{inline_r2(taug_Mt)} {{{results($R^2 = 11\%$)}}}).

There is a notable trend, wherein for high masses we have a shorter timescale

* Mass relations

Many of the galaxies masses have a high correlation with each other, and also help us undarstand the previous calculations.

#+begin_src python :results none
cols_to_use = dtg.columns.difference(df.columns)
dm = pd.merge(df, dtg[cols_to_use], left_index=True, right_index=True, how='outer')

#+end_src

#+begin_src python
mhi_SMass = simple_regplot(dm,"logStellarMass","logMHI")
mhi_SMass_ = simple_regplot(dm,"logStellarMass","logMHI",scatter_kws={"c": dm[""]})
#+end_src

#+begin_src python
mg_SMass = simple_regplot(dm,"log_tsf","log_Mass_ratio")
mg_SMass_ = simple_regplot(dm,"log_tsf","log_Mass_ratio",scatter_kws={"c": dm["log_tau_g"]})
#+end_src

#+RESULTS:
:results:
:end:

#+begin_src python

SMass_m26 = simple_regplot(dm,"logStellarMass","logM26")
SMass_m26_ = simple_regplot(dm,"logStellarMass","logM26",scatter_kws={"c": dm["log_tau_g"]})
#+end_src

#+begin_src python
mg_m26 = simple_regplot(dm,"logMg","logM26")
#+end_src

#+begin_src python
SMass_mt_tg = simple_regplot(dm,"logStellarMass","logMt",scatter_kws = {"c": dm["log_tau_g"]})
SMass_mt_SFR = simple_regplot(dm,"logStellarMass","logMt",scatter_kws = {"c": dm["log_SFR_0"]})
SMass_mt_mg = simple_regplot(dm,"logStellarMass","logMt",scatter_kws = {"c": dm["logMg"]})
SMass_mt_ratio = simple_regplot(dm,"logStellarMass","logMt",scatter_kws = {"c": dm["log_Mass_ratio"]})
SMass_mt_color = simple_regplot(dm,"logStellarMass","logMt",scatter_kws = {"c": dm["color"]})
#+end_src
#+begin_src python
mg_mt = simple_regplot(dm,"logMg","logMt",scatter_kws = {"c":dm['log_SFR_0']})
mg_mt = simple_regplot(dm,"logMg","logMt",scatter_kws = {"c":dm['log_tau_g']})
mg_mt = simple_regplot(dm,"logMg","logMt",scatter_kws = {"c":dm['logStellarMass']})
#+end_src
#+begin_src python
m26_mt = simple_regplot(dm,"logM26","logMt")
#+end_src

#+begin_src python
simple_regplot(dm,"log_tsf","log_Mass_ratio",scatter_kws={"c": dm["color"]})[1]

#+end_src

#+RESULTS:
:results:
#+caption:None
#+name: fig:None
#+label: fig:None
[[./figs/log_tsf-log_Mass_ratio-color_color.png]]
:end:

As expected, the older the galaxy the mass ratio is higher, and the color index agrees (\?)




\pagebreak
#+print_bibliography:



* Footnotes

[fn:1] TType=Morphology type code according to the classification by de Vaucouleurs/ Tdw1=Dwarf galaxy morphology/ Tdw2=Dwarf galaxy surface brightness morphology

